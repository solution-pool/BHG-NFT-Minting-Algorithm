<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coral Normal 1</title>
  <style>
    body {
      padding: 0;
      margin: 0;
    }
  </style>
</head>
<body>
    <canvas id="canvas">
        <script>
            Math.seedrandom=function(s){
                var mask=0xffffffff,m_w=(123456789+s)&mask,m_z=(987654321-s)&mask;
                return function(){m_z=(36969*(m_z&65535)+(m_z>>>16))&mask;m_w=(18000*(m_w&65535)+(m_w>>>16))&mask;
                    var result=((m_z<<16)+(m_w&65535))>>>0;result/=4294967296;return result;
                }
            };
            function _a(a, n, v) {
                for(let i = 0; i < n; i ++)
                    a[i] = v
                return a
            }
            function _b(v, e, ve) {
                if(ve[2*v] < 0) {
                    ve[2*v] = e
                } else {
                    ve[2*v + 1] = e
                }
            }

            function _c(v, e, ve) {
                if(ve[2*v] == e ) {
                    ve[2*v] = ve[2*v + 1]
                    ve[2*v + 1] = -1
                } else if(ve[2*v + 1] == e) {
                    ve[2*v + 1] = -1
                }

                return ve
            }

            function _d (df, d, limit) {
                const edgeNumber  = df._o()
                let rnd = []
                let rndmask = []
                for(let i = 0; i < edgeNumber ; i ++)
                    rnd.push(Math.random())
                const rndLength = rnd.length
                for(i = 0; i < rndLength ; i ++) {
                    if(rnd[i] > limit || !rnd[i]) continue
                    rndmask.push(i)
                }
                let rndmaskLength = rndmask.length
                for(let i = 0 ; i < rndmaskLength; i ++) {
                    let l = df._k(rndmask[i])

                    if(l < d) 
                        continue

                    try {
                        df._m(rndmask[i])
                    } 
                    catch(e) {
                        continue
                    }
                }
            }
            class Segments {

                constructor(nmax, zonewidth) {
                    this.X = []
                    _a(this.X, nmax, 0)
                    this.Y = []
                    _a(this.Y, nmax, 0)
                    this.VA = []
                    _a(this.VA, nmax, 0)
                    this.VS = []
                    _a(this.VS, nmax, -1)
                    this.EV = []
                    _a(this.EV, 2*nmax, -1)
                    this.VE = []
                    _a(this.VE, 2* nmax, -1)

                    this.nmax = nmax
                    this.vnum = 0
                    this.edgeNumber = 0
                    this.snum = 0
                    this.zonewidth = zonewidth
                    this.nz = 1 /zonewidth
                    if (this.nz<3) {
                        this.nz = 1
                        this.zonewidth = 1
                    }
                    this.zonemap = new Zonemap(this.nz)
                    this.zonemap.__v(this.X, this.Y)
                }

                __e(x,  y) {
                    if (x<0 || x>1 || y<0 || y>1)
                        return -1
                    return 1
                }

                _f(x, y, s) {
                    if (this.__e(x,y)<0) {
                        throw new Error("Vertext outside unit square.")
                    }

                    const vnum = this.vnum
                    
                    this.X[vnum] = x
                    this.Y[vnum] = y
                    this.VA[vnum] = 1
                    this.VS[vnum] = s

                    this.zonemap._ab(vnum)

                    this.vnum = vnum + 1
                    return vnum
                }

                _g(v1,  v2) {
                    v1 = parseInt(v1)
                    v2 = parseInt(v2)
                    const edgeNumber = this.edgeNumber
                    this.EV[2*edgeNumber] = v1
                    this.EV[2*edgeNumber+1] = v2

                    _b(v1, edgeNumber, this.VE)
                    _b(v2, edgeNumber, this.VE)

                    this.edgeNumber += 1
                    return edgeNumber
                }

                _h(e1) {
                    if (this.EV[2*e1]>-1 && this.EV[2*e1+1]>-1) 
                        return 1
                    return -1
                }

                __del_edge(e1) {

                    if (e1<0 || e1>this.edgeNumber-1) {
                        throw new Error("invalid edge in __del_edge e1" + e1)
                    }

                    let v1 = this.EV[2*e1]
                    let v2 = this.EV[2*e1+1]

                    this.EV[2*e1] = -1
                    this.EV[2*e1+1] = -1

                    if (v1>-1) {
                    _c(v1, e1, this.VE)
                    }
                    if (v2>-1) {
                    _c(v2, e1, this.VE)
                    }

                    return 1
                }   

                _j(a) {

                    let edgeNumber = this.edgeNumber
                    let n = 0

                    for (let e = 0; e < edgeNumber; e ++ ) {

                        if (this.EV[2*e]>-1) {

                            let v1 = this.EV[2*e]
                            let v2 = this.EV[2*e+1]
                            a[n][0] = this.X[v1]
                            a[n][1] = this.Y[v1]
                            a[n][2] = this.X[v2]
                            a[n][3] = this.Y[v2]

                            n+=1
                        }
                    }

                    return n
                }

                _k(e1) {

                    let nx = this.X[this.EV[2*e1]] - this.X[this.EV[2*e1+1]]
                    let ny = this.Y[this.EV[2*e1]] - this.Y[this.EV[2*e1+1]]
                    let length = Math.sqrt(nx*nx+ny*ny)

                    return length
                }

                _l(x, y, r, angles) {
                
                    let vertices = []
                    let snum = this.snum

                    let num_angles = angles.length

                    for (let i = 0; i < num_angles; i ++) {
                        const the = angles[i]

                        const xx = x + Math.cos(the)*r
                        const yy = y + Math.sin(the)*r

                        vertices.push(this._f(xx,yy,snum))
                    }

                    for (let i = 0; i < vertices.length-1; i ++) {
                        this._g(vertices[i],vertices[i+1])
                    }

                    this._g(vertices[0],vertices[num_angles-1])
                    this.snum = snum+1
                }

                _m(e1, minimum_length=-1.) {
                    if (this._h(e1)<0) {
                        throw new Error("e1 does not exist")
                    }
                    if (e1<0) {
                        throw new Error("invalid edge in _m e1" + e1)
                    }

                    let v1 = this.EV[2*e1]
                    let v2 = this.EV[2*e1+1]

                    let s = this.VS[v1]

                    if (s<0) {
                        throw new Error("Invalid segment id.")
                    }

                    if (minimum_length>0) {
                        let dx = this.X[v1] - this.X[v2]
                        let dy = this.Y[v1] - this.Y[v2]

                        if (dx*dx+dy*dy<minimum_length*minimum_length) {
                        throw new Error("edge too short, e1," + e1)
                        }
                    }

                    let midx = (this.X[v1] + this.X[v2])*0.5
                    let midy = (this.Y[v1] + this.Y[v2])*0.5

                    let v3 = this._f(midx,midy,s)
                    this.__del_edge(e1)

                    this._g(v1,v3)
                    this._g(v2,v3)

                    return 1
                }

                _n(limit) {
                    let vnum = this.vnum
                    for (let i = 0 ; i < vnum ; i ++) {
                        if( this.X[i] < ((RS - CURRENTSIZE) / 2 / RS + limit) || this.X[i] > (1 - (RS - CURRENTSIZE) / 2 / RS - limit) ) {
                            return - 1
                        }
                        if(this.Y[i] < ((RS - CURRENTSIZE) / 2 / RS + limit) || this.Y[i] > (1 - (RS - CURRENTSIZE) / 2 / RS - limit)) {
                            return -1
                        }
                    }
                    return 1
                }

                _o() {
                    return this.edgeNumber
                }
                
            }
            class DifferentialLine extends Segments {

                constructor(nmax, zonewidth, nearl, farl) {
                    super(nmax, zonewidth)

                    this.SX = new Array()
                    this.SY = new Array()
                    this.SD = new Array()

                    this.nearl = nearl
                    this.farl = farl
                }

                _q(step) {
                    let vertices = new Array()
                    const vnumCount = this.vnum
                    for(let v = 0; v < vnumCount; v ++ ) {
                        this.SX[v] = 0
                        this.SY[v] = 0
                        let num = this.zonemap._aa(
                            this.X[v],
                            this.Y[v],
                            this.farl,
                            vertices
                        )
                        this.__r(
                            v, 
                            vertices,
                            num, 
                            step,
                            this.SX,
                            this.SY
                        )

                    }
                    for (let v = 0; v < vnumCount ; v ++) {
                        if(this.VA[v] < 0) continue
                        this.X[v] = this.X[v] + this.SX[v]
                        this.Y[v] = this.Y[v] + this.SY[v]
                    }

                    for(let v = 0; v < vnumCount; v ++) {
                        if(this.VA[v] < 0) continue
                        try {
                            this.zonemap.___ad(v)
                        }
                        catch {
                        }
                    }
                }

                __r(v, vertices, num, step, sx, sy) {
                    if(this.VA[v] < 1) return -1
                    let e1 = this.VE[2*v]
                    let e2 = this.VE[2*v + 1]
                    let v1, v2
                    
                    if(this.EV[2*e1] == v) {
                        v1 = this.EV[2*e1 + 1]
                    } else {
                        v1 = this.EV[2*e1]
                    }

                    if(this.EV[2*e2] == v) {
                        v2 = this.EV[2*e2 + 1]
                    } else {
                        v2 =  this.EV[2*e2]
                    }

                    let resx = 0
                    let resy = 0

                    for(let k = 0; k < num; k ++) {
                        let neigh =  vertices[k]
                        let dx = this.X[v] - this.X[neigh]
                        let dy =  this.Y[v] -  this.Y[neigh]

                        let nrm = Math.sqrt(dx * dx + dy * dy)

                        if(neigh == v1 || neigh == v2) {
                            if(nrm < this.nearl || nrm <= 0) continue
                            
                            resx += -dx/nrm *step
                            resy += -dy/nrm * step
                        } else {
                            if(nrm > this.farl || nrm <= 0) continue
                            resx += dx * (this.farl/nrm -1) *step
                            resy += dy * (this.farl/nrm-1)*step
                        }
                    }
                    sx[v] += resx
                    sy[v] += resy

                    return 1
                }
            }

            function _s() {
                ctx.fillStyle = 'rgb(' + BACK.toString() + ')'
                ctx.fillRect(0,0,SIZE,SIZE)
            }

            function _t(x1, y1, x2, y2, r, nmin = 2, fill=false) {
                let dx = x1 - x2
                let dy = y1 - y2

                let dd = Math.sqrt(dx ** 2 + dy ** 2)
                let n = parseInt(dd / ONE) 
                if(n < nmin) n = nmin
                let a = Math.atan2(dy, dx)
                let scale = _u(0, dd, n)
                for(let i = 0; i < scale.length; i ++ ) {
                    let xp = x1 - scale[i] * Math.cos(a)
                    let yp = y1 - scale[i] * Math.sin(a)
                    ctx.beginPath()
                    if(fill) {
                        if(!gf || pe) {
                            ctx.strokeStyle = 'rgb(' + BACK.toString() + ')'
                        } else {
                            if(CO < 5) {
                                ctx.strokeStyle = 'rgb(' + init_front.toString() + ')'
                            } else {
                                ctx.strokeStyle = 'rgb(' + cf.toString() + ')'
                            }
                        }
                    } else {
                        if(CO < 5) {
                            ctx.strokeStyle = 'rgb(' + init_front.toString() + ')'
                        } else {
                            ctx.strokeStyle = 'rgb(' + cf.toString() + ')'
                        }
                    }
                    ctx.arc(xp * RS, yp * RS, r * RS, 0, TWOPI)
                    ctx.stroke()
                }
            }

            function _u(start, stop, num, endpoint = true) {
                const div = endpoint ? (num - 1) : num;
                const step = (stop - start) / div;
                return Array.from({length: num}, (_, i) => start + step * i);
            }

            class Zonemap {

                constructor(nz) {
                    nz = parseInt(nz)
                    const total_zones = nz ** 2
                    this.VZ                     = []
                    this.Z                      = []

                    this.vnum                   = 0
                    this.vsize                  = RS

                    this.nz                     = nz
                    this.total_zones            = nz*nz
                    this.greatest_zone_size     = RS

                    for (let i = 0; i < this.total_zones ; i ++) {

                        let z = []

                        z.i = i
                        z.size = RS
                        z.count = 0
                        z.ZV = []

                        this.Z[i] = z
                    }

                }
                __v(X,Y) {
                    this.X = X
                    this.Y = Y
                }
                _w(z1, v1) {
                
                    z1 = parseInt(z1)
                    v1 = parseInt(v1)

                    let z = this.Z[z1]
                    if(z == undefined) {
                        z = []
                        z.count = 0
                        z.ZV = []
                        z.i = 0
                        z.size = SIZE

                        this.Z.push(z)
                    }
                    z.ZV[z.count] = v1
                    z.count += 1
                    if (z.count>=z.size-1)
                        return this._v(z)
                    return 1
                }
                _v(z) {
                    let new_size = z.size*2
                    const new_zv = []
                    z.ZV = new_zv;
                    z.size = new_size
                    if (new_size>this.greatest_zone_size)
                        this.greatest_zone_size = new_size
                    this.Z.push(z)
                    return 1
                }
                _y(z1, v1) {
                    z1 = parseInt(z1)
                    v1 = parseInt(v1)

                    let z = this.Z[z1]
                    for (let i = 0; i < z.count ;  i ++) {

                        if (z.ZV[i] == v1) {
                            z.ZV[i] = z.ZV[z.count-1]
                            z.count -= 1
                            return 1
                        }
                    }

                    return -1
                }
                _z(x, y) {

                    const nz = this.nz

                    const i = parseInt(x*nz)
                    const j = parseInt(y*nz)
                    const z = nz*i + j

                    return z
                }
                _aa(x, y, rad, vertices) {

                    const nz = this.nz

                    const zx = parseInt(x*nz)
                    const zy = parseInt(y*nz)

                    let num = 0

                    const rad2 = rad*rad


                    for (let a = Math.max(zx-1,0); a < Math.min(zx+2,nz); a ++) {
                        for (let b = Math.max(zy-1,0); b < Math.min(zy+2,nz); b ++ ) {
                            const z = this.Z[a*nz+b]
                            for (let i = 0; i < z.count; i ++) {

                                const dx = x-this.X[z.ZV[i]]
                                const dy = y-this.Y[z.ZV[i]]

                                if (dx*dx+dy*dy<rad2) {

                                    vertices[num] = z.ZV[i]
                                    num += 1
                                }
                            }
                        }
                    }
                    return num
                }
                _ab(v1) {
                    v1 = parseInt(v1)
                    let vnum = this.vnum

                    const x = this.X[v1]
                    const y = this.Y[v1]

                    const z1 = this._z(x,y)

                    this._w(z1, vnum)
                    this.VZ[vnum] = z1

                    const new_vz = []
                    
                    if (this.vnum>=this.vsize-1) {
                        this.VZ = new_vz;
                        this.vsize = this.vsize*2
                    }

                    this.vnum += 1
                    return vnum
                }
                _ac(v1) {
                    this._y(this.VZ[v1], v1)
                    this.VZ[v1] = -1
                    return 1
                }
                _ad(v1) {
                    v1 = parseInt(v1)
                    const x = this.X[v1]
                    const y = this.Y[v1]
                    const new_z = parseInt(this._z(x, y))
                    const old_z = parseInt(this.VZ[v1])

                    if (old_z<0) {
                        return -1
                    }

                    if (new_z != old_z) {
                        this._y(old_z, v1)
                        this._w(new_z, v1)
                        this.VZ[v1] = new_z

                        return 1
                    }

                    return -1
                }
            }
            // Those variables contain the trait of the coral.

            const SIZE          = 400       // Growth size
            const CO   = 5         // Coloroption
            const RYTHM         = 3         // Growth RYTHM
            const INDEX         = 1
            const RS      = SIZE
            const NMAX          = 10 ** 5
            const ONE           = 1 / RS
            const STP           = ONE
            const NEARL         = 3 * ONE
            const FARL          = 30 * ONE
            const INIT_RAD      = 6 * ONE
            const INIT_NUM      = 4
            const MID           = 0.5
            const TWOPI         = 2 * Math.PI
            let FRONT, BACK, CURRENTSIZE
            let np_coords = [], gf, DF, cf
            let sc = 1, sl, dp = [], pp = [], pn = parseInt(SIZE / 30), ps = false, pe = false, pf = false
            let cs = [], ci = 0, co = 1, fs = []
            let ctx, init_front

            function preload() {
                FRONT = [[255, 0,0], [0,255,0]]
                BACK    = [0,0,0]
                let first = FRONT[0]
                let last  = FRONT[1]

                if(first[0] > last[0]) {
                for(let i = first[0]; i >= last[0]; i --) {
                    cs.push([i, first[1], first[2]])
                } 
                } else {
                for(let i = first[0]; i <= last[0]; i ++) {
                    cs.push([i, first[1], first[2]])
                }
                }

                if(first[1] > last[1]) {
                for(let i = first[1]; i >= last[1]; i --) {
                    cs.push([last[0], i, first[2]])
                } 
                } else {
                for(let i = first[1]; i <= last[1]; i ++) {
                    cs.push([last[0], i, first[2]])
                }
                }

                if(first[2] > last[2]) {
                for(let i = first[2]; i >= last[2]; i --) {
                    cs.push([last[0], last[1], i])
                } 
                } else {
                for(let i = first[2]; i <= last[2]; i ++) {
                    cs.push([last[0], last[1], i])
                }
                }
            }

            function setup() {
                let canvas = document.getElementById('canvas')
                canvas.width = SIZE
                canvas.height = SIZE
                ctx = canvas.getContext('2d')
                sc = 1
                if(RYTHM > 2) {
                    CURRENTSIZE = RS
                    step_unit   = parseInt(RS / (RYTHM - 1))
                    sl = parseInt(RS / (RYTHM - 1))
                } else {
                    sl = step_unit = CURRENTSIZE = RS
                }
                gf = true
                ci  = 0
                    
                Math.seedrandom(INDEX)
                if(CO > 4 && CO < 9) {
                    cf = FRONT[0]
                } else {
                    cf = FRONT
                }
                DF = new DifferentialLine(NMAX, FARL * 2, NEARL, FARL)

                let angles = []
                for(let i = 0; i < INIT_NUM ; i ++ ) {
                    angles.push(Math.random() * TWOPI)
                }
                angles.sort()
                DF._l(MID, MID, INIT_RAD, angles)
                init_front = cf
                draw()
            }

            function draw() {
                cf = cs[ci]
                if(ci >= cs.length - 1) {
                co = 2
                } 
                if(ci <= 0) {
                co = 1
                }

                if(co == 1) {
                ci ++
                } else {
                ci --
                }
                wrap()
                requestAnimationFrame(draw)
            }

            function wrap () {
                for(let i = 0; i < NMAX; i ++) {
                    np_coords[i] = [0,0,0,0]
                }
                let res     = steps(DF)
                let num     = DF._j(np_coords)
                let real  = np_coords.slice(0, num)

                if(ps) {
                    real = pp.shift() 
                    if(pp.length >= pn * sc) {
                        pe = true
                        pf = false
                    } else {
                        pe = false
                        pf = true
                    }
                } else {
                    if(gf) {
                        dp.push(real)
                    } else {
                        real = dp.pop()
                    }
                    if(real == undefined) {
                        setup()
                        return
                    }
                }
                _s()
                
                for(let i = 0; i < real.length; i ++) {
                    let point = real[i]
                    let x1 = point[0]
                    let y1 = point[1]
                    let x2 = point[2]
                    let y2 = point[3]

                    let r =  ONE / 3
                    _t(x1, y1, x2, y2, r)
                }
                return res
            }
            function steps(df) {
                if(ps) {
                    if(pp.length == 0) {
                    ps = false
                    if(sc < RYTHM - 1) {
                        sc ++
                    } else {
                        sc = 1
                    }
                    sl = step_unit * sc
                    }
                } else {
                    if(gf) {
                    df._q(STP)
                    _d(df, NEARL, 0.5)
                    }
                    if(check_step(sl, df)) {
                        if(sc < RYTHM - 1) {
                            ps = true
                            let drawLength = dp.length
                            for(let i = 1; i <= pn * sc; i ++ ) {
                            pp.push(dp[drawLength - i])
                            }
                            for(let i = pn * sc; i > 0; i -- ) {
                            pp.push(dp[drawLength - i])
                            }
                        } else {
                            if(RYTHM == 1) {
                                cancelAnimationFrame(draw)
                            }                                                                                                                                                           

                            if(gf) {
                                cancelAnimationFrame(draw)
                                sleep(parseInt(RYTHM + 1) * 1000)
                                requestAnimationFrame(draw)
                            }
                            gf = false
                        }
                    }
                }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
            }

            function check_step(step, df) {
                CURRENTSIZE = step
                let result = df._n(3 * STP) < 0
                CURRENTSIZE = RS
                return result
            }

            function sleep(milliseconds) {
                const date = Date.now();
                let currentDate = null;
                do {
                    currentDate = Date.now();
                } while (currentDate - date < milliseconds);
            }
            preload()
            setup()
        </script>
    </canvas>
</body>
</html>