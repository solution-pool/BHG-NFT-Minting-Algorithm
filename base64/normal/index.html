<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coral Normal 1</title>
  <style>
    body {
      padding: 0;
      margin: 0;
    }
  </style>
</head>
<body>
    <canvas id="canvas">
        <script>
            Math.seedrandom=function(s){
                var mask=0xffffffff,m_w=(123456789+s)&mask,m_z=(987654321-s)&mask;
                return function(){m_z=(36969*(m_z&65535)+(m_z>>>16))&mask;m_w=(18000*(m_w&65535)+(m_w>>>16))&mask;
                    var result=((m_z<<16)+(m_w&65535))>>>0;result/=4294967296;return result;
                }
            };
            function long_array_init(a, n, v) {
                for(let i = 0; i < n; i ++)
                    a[i] = v
                return a
            }
            function add_e_to_ve(v, e, ve) {
                if(ve[2*v] < 0) {
                    ve[2*v] = e
                } else {
                    ve[2*v + 1] = e
                }
            }

            function del_e_from_ve(v, e, ve) {
                if(ve[2*v] == e ) {
                    ve[2*v] = ve[2*v + 1]
                    ve[2*v + 1] = -1
                } else if(ve[2*v + 1] == e) {
                    ve[2*v + 1] = -1
                }

                return ve
            }

            function spawn (df, d, limit) {
                const edgeNumber  = df.get_enum()
                let rnd = []
                let rndmask = []
                for(let i = 0; i < edgeNumber ; i ++)
                    rnd.push(Math.random())
                const rndLength = rnd.length
                for(i = 0; i < rndLength ; i ++) {
                    if(rnd[i] > limit || !rnd[i]) continue
                    rndmask.push(i)
                }
                let rndmaskLength = rndmask.length
                for(let i = 0 ; i < rndmaskLength; i ++) {
                    let l = df.get_edge_length(rndmask[i])

                    if(l < d) 
                        continue

                    try {
                        df.split_edge(rndmask[i])
                    } 
                    catch(e) {
                        continue
                    }
                }
            }
            class Segments {

                constructor(nmax, zonewidth) {
                    this.X = []
                    long_array_init(this.X, nmax, 0)
                    this.Y = []
                    long_array_init(this.Y, nmax, 0)
                    this.VA = []
                    long_array_init(this.VA, nmax, 0)
                    this.VS = []
                    long_array_init(this.VS, nmax, -1)
                    this.EV = []
                    long_array_init(this.EV, 2*nmax, -1)
                    this.VE = []
                    long_array_init(this.VE, 2* nmax, -1)

                    this.nmax = nmax
                    this.vnum = 0
                    this.edgeNumber = 0
                    this.snum = 0
                    this.zonewidth = zonewidth
                    this.nz = 1 /zonewidth
                    if (this.nz<3) {
                        this.nz = 1
                        this.zonewidth = 1
                    }
                    this.zonemap = new Zonemap(this.nz)
                    this.zonemap.__assign_xy_arrays(this.X, this.Y)
                }

                __valid_new_vertex(x,  y) {
                    if (x<0 || x>1 || y<0 || y>1)
                        return -1
                    return 1
                }

                __add_vertex(x, y, s) {
                    if (this.__valid_new_vertex(x,y)<0) {
                        throw new Error("Vertext outside unit square.")
                    }

                    const vnum = this.vnum
                    
                    this.X[vnum] = x
                    this.Y[vnum] = y
                    this.VA[vnum] = 1
                    this.VS[vnum] = s

                    this.zonemap.add_vertex(vnum)

                    this.vnum = vnum + 1
                    return vnum
                }

                __add_edge(v1,  v2) {
                    v1 = parseInt(v1)
                    v2 = parseInt(v2)
                    const edgeNumber = this.edgeNumber
                    this.EV[2*edgeNumber] = v1
                    this.EV[2*edgeNumber+1] = v2

                    add_e_to_ve(v1, edgeNumber, this.VE)
                    add_e_to_ve(v2, edgeNumber, this.VE)

                    this.edgeNumber += 1
                    return edgeNumber
                }

                __edge_exists(e1) {
                    if (this.EV[2*e1]>-1 && this.EV[2*e1+1]>-1) 
                        return 1
                    return -1
                }

                __del_vertex(v1) {

                    this.VA[v1] = -1

                    this.zonemap.del_vertex(v1)

                    return 1
                }

                __del_edge(e1) {

                    if (e1<0 || e1>this.edgeNumber-1) {
                        throw new Error("invalid edge in __del_edge e1" + e1)
                    }

                    let v1 = this.EV[2*e1]
                    let v2 = this.EV[2*e1+1]

                    this.EV[2*e1] = -1
                    this.EV[2*e1+1] = -1

                    if (v1>-1) {
                    del_e_from_ve(v1, e1, this.VE)
                    }
                    if (v2>-1) {
                    del_e_from_ve(v2, e1, this.VE)
                    }

                    return 1
                }   

                np_get_edges_coordinates(a) {

                    let edgeNumber = this.edgeNumber
                    let n = 0

                    for (let e = 0; e < edgeNumber; e ++ ) {

                        if (this.EV[2*e]>-1) {

                            let v1 = this.EV[2*e]
                            let v2 = this.EV[2*e+1]
                            a[n][0] = this.X[v1]
                            a[n][1] = this.Y[v1]
                            a[n][2] = this.X[v2]
                            a[n][3] = this.Y[v2]

                            n+=1
                        }
                    }

                    return n
                }

                get_edge_length(e1) {

                    let nx = this.X[this.EV[2*e1]] - this.X[this.EV[2*e1+1]]
                    let ny = this.Y[this.EV[2*e1]] - this.Y[this.EV[2*e1+1]]
                    let length = Math.sqrt(nx*nx+ny*ny)

                    return length
                }

                init_circle_segment(x, y, r, angles) {
                
                    let vertices = []
                    let snum = this.snum

                    let num_angles = angles.length

                    for (let i = 0; i < num_angles; i ++) {
                        const the = angles[i]

                        const xx = x + Math.cos(the)*r
                        const yy = y + Math.sin(the)*r

                        vertices.push(this.__add_vertex(xx,yy,snum))
                    }

                    for (let i = 0; i < vertices.length-1; i ++) {
                        this.__add_edge(vertices[i],vertices[i+1])
                    }

                    this.__add_edge(vertices[0],vertices[num_angles-1])
                    this.snum = snum+1
                }

                split_edge(e1, minimum_length=-1.) {
                    if (this.__edge_exists(e1)<0) {
                        throw new Error("e1 does not exist")
                    }
                    if (e1<0) {
                        throw new Error("invalid edge in split_edge e1" + e1)
                    }

                    let v1 = this.EV[2*e1]
                    let v2 = this.EV[2*e1+1]

                    let s = this.VS[v1]

                    if (s<0) {
                        throw new Error("Invalid segment id.")
                    }

                    if (minimum_length>0) {
                        let dx = this.X[v1] - this.X[v2]
                        let dy = this.Y[v1] - this.Y[v2]

                        if (dx*dx+dy*dy<minimum_length*minimum_length) {
                        throw new Error("edge too short, e1," + e1)
                        }
                    }

                    let midx = (this.X[v1] + this.X[v2])*0.5
                    let midy = (this.Y[v1] + this.Y[v2])*0.5

                    let v3 = this.__add_vertex(midx,midy,s)
                    this.__del_edge(e1)

                    this.__add_edge(v1,v3)
                    this.__add_edge(v2,v3)

                    return 1
                }

                safe_vertex_positions(limit) {
                    let vnum = this.vnum
                    for (let i = 0 ; i < vnum ; i ++) {
                        if( this.X[i] < ((RS - CURRENTSIZE) / 2 / RS + limit) || this.X[i] > (1 - (RS - CURRENTSIZE) / 2 / RS - limit) ) {
                            return - 1
                        }
                        if(this.Y[i] < ((RS - CURRENTSIZE) / 2 / RS + limit) || this.Y[i] > (1 - (RS - CURRENTSIZE) / 2 / RS - limit)) {
                            return -1
                        }
                    }
                    return 1
                }

                get_enum() {
                    return this.edgeNumber
                }
                
            }
            class DifferentialLine extends Segments {

                constructor(nmax, zonewidth, nearl, farl) {
                    super(nmax, zonewidth)

                    this.SX = new Array()
                    this.SY = new Array()
                    this.SD = new Array()

                    this.nearl = nearl
                    this.farl = farl
                }

                optimize_position(step) {
                    let vertices = new Array()
                    const vnumCount = this.vnum
                    for(let v = 0; v < vnumCount; v ++ ) {
                        this.SX[v] = 0
                        this.SY[v] = 0
                        let num = this.zonemap.__sphere_vertices(
                            this.X[v],
                            this.Y[v],
                            this.farl,
                            vertices
                        )
                        this.__reject(
                            v, 
                            vertices,
                            num, 
                            step,
                            this.SX,
                            this.SY
                        )

                    }
                    for (let v = 0; v < vnumCount ; v ++) {
                        if(this.VA[v] < 0) continue
                        this.X[v] = this.X[v] + this.SX[v]
                        this.Y[v] = this.Y[v] + this.SY[v]
                    }

                    for(let v = 0; v < vnumCount; v ++) {
                        if(this.VA[v] < 0) continue
                        try {
                            this.zonemap.__update_v(v)
                        }
                        catch {
                        }
                    }
                }

                __reject(v, vertices, num, step, sx, sy) {
                    if(this.VA[v] < 1) return -1
                    let e1 = this.VE[2*v]
                    let e2 = this.VE[2*v + 1]
                    let v1, v2
                    
                    if(this.EV[2*e1] == v) {
                        v1 = this.EV[2*e1 + 1]
                    } else {
                        v1 = this.EV[2*e1]
                    }

                    if(this.EV[2*e2] == v) {
                        v2 = this.EV[2*e2 + 1]
                    } else {
                        v2 =  this.EV[2*e2]
                    }

                    let resx = 0
                    let resy = 0

                    for(let k = 0; k < num; k ++) {
                        let neigh =  vertices[k]
                        let dx = this.X[v] - this.X[neigh]
                        let dy =  this.Y[v] -  this.Y[neigh]

                        let nrm = Math.sqrt(dx * dx + dy * dy)

                        if(neigh == v1 || neigh == v2) {
                            if(nrm < this.nearl || nrm <= 0) continue
                            
                            resx += -dx/nrm *step
                            resy += -dy/nrm * step
                        } else {
                            if(nrm > this.farl || nrm <= 0) continue
                            resx += dx * (this.farl/nrm -1) *step
                            resy += dy * (this.farl/nrm-1)*step
                        }
                    }
                    sx[v] += resx
                    sy[v] += resy

                    return 1
                }
            }

            const color = [
                [255, 0 , 0],
                [255, 0 , 36],
                [255, 0 , 72],
                [255, 0 , 108],
                [255, 0 , 144],
                [255, 0 , 180],
                [255, 0 , 216],
                [255, 0 , 255],
                [216, 0 , 255],
                [180, 0 , 255],
                [144, 0 , 255],
                [108, 0 , 255],
                [72, 0 , 255],
                [36, 0 , 255],
                [0, 0 , 255],
                [0, 36 , 255],
                [0, 72 , 255],
                [0, 108 , 255],
                [0, 144 , 255],
                [0, 180 , 255],
                [0, 216 , 255],
                [0, 255 , 255],
                [0, 255 , 216],
                [0, 255 , 180],
                [0, 255 , 144],
                [0, 255 , 108],
                [0, 255 , 72],
                [0, 255 , 36],
                [0, 255 , 0],
                [36, 255 , 0],
                [72, 255 , 0],
                [108, 255 , 0],
                [144, 255 , 0],
                [180, 255 , 0],
                [216, 255 , 0],
                [255, 255 , 0],
                [255, 216 , 0],
                [255, 180 , 0],
                [255, 144 , 0],
                [255, 108 , 0],
                [255, 72 , 0],
                [255, 36 , 0],
            ]

            function clear_canvas() {
                ctx.fillStyle = 'rgb(' + BACK.toString() + ')'
                ctx.fillRect(0,0,SIZE,SIZE)
            }

            function circles(x1, y1, x2, y2, r, nmin = 2, fill=false) {
                let dx = x1 - x2
                let dy = y1 - y2

                let dd = Math.sqrt(dx ** 2 + dy ** 2)
                let n = parseInt(dd / ONE) 
                if(n < nmin) n = nmin
                let a = Math.atan2(dy, dx)
                let scale = linspace(0, dd, n)
                for(let i = 0; i < scale.length; i ++ ) {
                    let xp = x1 - scale[i] * Math.cos(a)
                    let yp = y1 - scale[i] * Math.sin(a)
                    ctx.beginPath()
                    if(fill) {
                        if(!growth_flag || pulse_erase) {
                            ctx.strokeStyle = 'rgb(' + BACK.toString() + ')'
                        } else {
                            if(CO < 5) {
                                ctx.strokeStyle = 'rgb(' + init_front.toString() + ')'
                            } else {
                                ctx.strokeStyle = 'rgb(' + current_front.toString() + ')'
                            }
                        }
                    } else {
                        if(CO < 5) {
                            ctx.strokeStyle = 'rgb(' + init_front.toString() + ')'
                        } else {
                            ctx.strokeStyle = 'rgb(' + current_front.toString() + ')'
                        }
                    }
                    ctx.arc(xp * RS, yp * RS, r * RS, 0, TWOPI)
                    ctx.stroke()
                }
            }

            function linspace(start, stop, num, endpoint = true) {
                const div = endpoint ? (num - 1) : num;
                const step = (stop - start) / div;
                return Array.from({length: num}, (_, i) => start + step * i);
            }

            class Zonemap {

                constructor(nz) {
                    nz = parseInt(nz)
                    const total_zones = nz ** 2
                    this.VZ                     = []
                    this.Z                      = []

                    this.vnum                   = 0
                    this.vsize                  = RS

                    this.nz                     = nz
                    this.total_zones            = nz*nz
                    this.greatest_zone_size     = RS

                    for (let i = 0; i < this.total_zones ; i ++) {

                        let z = []

                        z.i = i
                        z.size = RS
                        z.count = 0
                        z.ZV = []

                        this.Z[i] = z
                    }

                }
                __assign_xy_arrays(X,Y) {
                    this.X = X
                    this.Y = Y
                }
                __add_v_to_zone(z1, v1) {
                
                    z1 = parseInt(z1)
                    v1 = parseInt(v1)

                    let z = this.Z[z1]
                    if(z == undefined) {
                        z = []
                        z.count = 0
                        z.ZV = []
                        z.i = 0
                        z.size = SIZE

                        this.Z.push(z)
                    }
                    z.ZV[z.count] = v1
                    z.count += 1
                    if (z.count>=z.size-1)
                        return this.__extend_zv_of_zone(z)
                    return 1
                }
                __extend_zv_of_zone(z) {
                    let new_size = z.size*2
                    const new_zv = []
                    z.ZV = new_zv;
                    z.size = new_size
                    if (new_size>this.greatest_zone_size)
                        this.greatest_zone_size = new_size
                    this.Z.push(z)
                    return 1
                }
                __remove_v_from_zone(z1, v1) {
                    z1 = parseInt(z1)
                    v1 = parseInt(v1)

                    let z = this.Z[z1]
                    for (let i = 0; i < z.count ;  i ++) {

                        if (z.ZV[i] == v1) {
                            z.ZV[i] = z.ZV[z.count-1]
                            z.count -= 1
                            return 1
                        }
                    }

                    return -1
                }
                __get_z(x, y) {

                    const nz = this.nz

                    const i = parseInt(x*nz)
                    const j = parseInt(y*nz)
                    const z = nz*i + j

                    return z
                }
                __sphere_vertices(x, y, rad, vertices) {

                    const nz = this.nz

                    const zx = parseInt(x*nz)
                    const zy = parseInt(y*nz)

                    let num = 0

                    const rad2 = rad*rad


                    for (let a = Math.max(zx-1,0); a < Math.min(zx+2,nz); a ++) {
                        for (let b = Math.max(zy-1,0); b < Math.min(zy+2,nz); b ++ ) {
                            const z = this.Z[a*nz+b]
                            for (let i = 0; i < z.count; i ++) {

                                const dx = x-this.X[z.ZV[i]]
                                const dy = y-this.Y[z.ZV[i]]

                                if (dx*dx+dy*dy<rad2) {

                                    vertices[num] = z.ZV[i]
                                    num += 1
                                }
                            }
                        }
                    }
                    return num
                }
                add_vertex(v1) {
                    v1 = parseInt(v1)
                    let vnum = this.vnum

                    const x = this.X[v1]
                    const y = this.Y[v1]

                    const z1 = this.__get_z(x,y)

                    this.__add_v_to_zone(z1, vnum)
                    this.VZ[vnum] = z1

                    const new_vz = []
                    
                    if (this.vnum>=this.vsize-1) {
                        this.VZ = new_vz;
                        this.vsize = this.vsize*2
                    }

                    this.vnum += 1
                    return vnum
                }
                del_vertex(v1) {
                    this.__remove_v_from_zone(this.VZ[v1], v1)
                    this.VZ[v1] = -1
                    return 1
                }
                update_v(v1) {
                    v1 = parseInt(v1)
                    const x = this.X[v1]
                    const y = this.Y[v1]
                    const new_z = parseInt(this.__get_z(x, y))
                    const old_z = parseInt(this.VZ[v1])

                    if (old_z<0) {
                        return -1
                    }

                    if (new_z != old_z) {
                        this.__remove_v_from_zone(old_z, v1)
                        this.__add_v_to_zone(new_z, v1)
                        this.VZ[v1] = new_z

                        return 1
                    }

                    return -1
                }
            }
            // Those variables contain the trait of the coral.

            const SIZE          = 400       // Growth size
            const CO   = 5         // Coloroption
            const RYTHM         = 3         // Growth RYTHM
            const INDEX         = 1
            const RS      = SIZE
            const NMAX          = 10 ** 5
            const ONE           = 1 / RS
            const STP           = ONE
            const NEARL         = 3 * ONE
            const FARL          = 30 * ONE
            const INIT_RAD      = 6 * ONE
            const INIT_NUM      = 4
            const MID           = 0.5
            const TWOPI         = 2 * Math.PI
            let FRONT, BACK, CURRENTSIZE
            let np_coords, np_vert_coords, growth_flag, DF, render, coloroptions, current_front
            let step_count = 1, step_length, draw_path = [], pulse_path = [], pulse_num = parseInt(SIZE / 30), pulse_start = false, pulse_erase = false, pulse_fill = false
            let currendColorStore = [], colorIndex = 0, co = 1, fullColorStack = []
            let ctx, init_front

            function preload() {
                let colorLength = color.length
                coloroptions = {
                    1 : {
                    BACK : [0,0,0],
                    FRONT : color[(INDEX % colorLength)]
                    },
                    2 : {
                    BACK : [255, 255, 255],
                    FRONT : color[(INDEX % colorLength)]
                    },
                    3 : {
                    BACK : color[(INDEX % colorLength)],
                    FRONT : [0, 0, 0]
                    },
                    4 : {
                    BACK : color[(INDEX % colorLength)],
                    FRONT : [255, 255, 255]
                    },
                    5 : {
                    BACK : [255, 255, 255],
                    FRONT : [
                        color[(INDEX % colorLength)],
                        color[((INDEX + 21) % colorLength)]
                    ]
                    },
                    6 : {
                    BACK : [0, 0, 0],
                    FRONT : [
                        color[(INDEX % colorLength)],
                        color[((INDEX + 21) % colorLength)]
                    ]
                    },
                    7 : {
                    BACK : [255, 255, 255],
                    FRONT : [
                        color[(INDEX % colorLength)],
                        color[((INDEX + 14) % colorLength)],
                        color[((INDEX + 28) % colorLength)]
                    ]
                    },
                    8 : {
                    BACK : [0, 0, 0],
                    FRONT : [
                        color[(INDEX % colorLength)],
                        color[((INDEX + 14) % colorLength)],
                        color[((INDEX + 28) % colorLength)]
                    ]
                    },
                    9 : {
                    BACK : [0, 0, 0],
                    FRONT : color[(INDEX % colorLength)]
                    }
                }
                FRONT = coloroptions[CO].FRONT
                BACK  = coloroptions[CO].BACK
                make_full_color_stack()
                make_color_store()
            }

            function make_full_color_stack() {
                for(let i = 0; i <256; i ++) {
                    fullColorStack.push([255, 0, i])
                }
                for(let i = 255; i >= 0; i --) {
                    fullColorStack.push([i, 0, 255])
                }
                for(let i = 0; i <256; i ++) {
                    fullColorStack.push([0, i, 255])
                }
                for(let i = 255; i >= 0; i --) {
                    fullColorStack.push([0, 255, i])
                }
                for(let i = 0; i <256; i ++) {
                    fullColorStack.push([i, 255, 0])
                }
                for(let i = 255; i >=0; i --) {
                    fullColorStack.push([255, i, 0])
                }
            }

            function make_color_store() {
            if(CO < 5)
                return

            if(CO == 5 || CO == 6) {
                let first = FRONT[0]
                let last  = FRONT[1]

                if(first[0] > last[0]) {
                for(let i = first[0]; i >= last[0]; i --) {
                    currendColorStore.push([i, first[1], first[2]])
                } 
                } else {
                for(let i = first[0]; i <= last[0]; i ++) {
                    currendColorStore.push([i, first[1], first[2]])
                }
                }

                if(first[1] > last[1]) {
                for(let i = first[1]; i >= last[1]; i --) {
                    currendColorStore.push([last[0], i, first[2]])
                } 
                } else {
                for(let i = first[1]; i <= last[1]; i ++) {
                    currendColorStore.push([last[0], i, first[2]])
                }
                }

                if(first[2] > last[2]) {
                for(let i = first[2]; i >= last[2]; i --) {
                    currendColorStore.push([last[0], last[1], i])
                } 
                } else {
                for(let i = first[2]; i <= last[2]; i ++) {
                    currendColorStore.push([last[0], last[1], i])
                }
                }
            } 
            else if(CO == 7 || CO == 8) {
                let first = FRONT[0]
                let second = FRONT[1]
                let last  = FRONT[2]

                if(first[0] > second[0]) {
                for(let i = first[0]; i >= second[0]; i --) {
                    currendColorStore.push([i, first[1], first[2]])
                } 
                } else {
                for(let i = first[0]; i <= second[0]; i ++) {
                    currendColorStore.push([i, first[1], first[2]])
                }
                }

                if(first[1] > second[1]) {
                for(let i = first[1]; i >= second[1]; i --) {
                    currendColorStore.push([second[0], i, first[2]])
                } 
                } else {
                for(let i = first[1]; i <= second[1]; i ++) {
                    currendColorStore.push([second[0], i, first[2]])
                }
                }

                if(first[2] > second[2]) {
                for(let i = first[2]; i >= second[2]; i --) {
                    currendColorStore.push([second[0], second[1], i])
                } 
                } else {
                for(let i = first[2]; i <= second[2]; i ++) {
                    currendColorStore.push([second[0], second[1], i])
                }
                }
                
                if(second[0] > last[0]) {
                for(let i = second[0]; i >= last[0]; i --) {
                    currendColorStore.push([i, second[1], second[2]])
                } 
                } else {
                for(let i = second[0]; i <= last[0]; i ++) {
                    currendColorStore.push([i, second[1], second[2]])
                }
                }

                if(second[1] > last[1]) {
                for(let i = second[1]; i >= last[1]; i --) {
                    currendColorStore.push([last[0], i, second[2]])
                } 
                } else {
                for(let i = second[1]; i <= last[1]; i ++) {
                    currendColorStore.push([last[0], i, second[2]])
                }
                }

                if(second[2] > last[2]) {
                for(let i = second[2]; i >= last[2]; i --) {
                    currendColorStore.push([last[0], last[1], i])
                } 
                } else {
                for(let i = second[2]; i <= last[2]; i ++) {
                    currendColorStore.push([last[0], last[1], i])
                }
                }
            }
            else {
                let stackLength = fullColorStack.length
                for(let i = 0; i < stackLength; i ++) {
                if(fullColorStack[i].join(',') === FRONT.join(',')) {
                    colorIndex = i
                    break
                }
                }
            }
            }

            function setup() {
                let canvas = document.getElementById('canvas')
                canvas.width = SIZE
                canvas.height = SIZE
                ctx = canvas.getContext('2d')
                step_count = 1
                if(RYTHM > 2) {
                    CURRENTSIZE = RS
                    step_unit   = parseInt(RS / (RYTHM - 1))
                    step_length = parseInt(RS / (RYTHM - 1))
                } else {
                    step_length = step_unit = CURRENTSIZE = RS
                }
                growth_flag = true
                if(CO < 9) 
                    colorIndex  = 0
                    
                Math.seedrandom(INDEX)
                if(CO > 4 && CO < 9) {
                    current_front = FRONT[0]
                } else {
                    current_front = FRONT
                }
                DF = new DifferentialLine(NMAX, FARL * 2, NEARL, FARL)

                let angles = []
                for(let i = 0; i < INIT_NUM ; i ++ ) {
                    angles.push(Math.random() * TWOPI)
                }
                angles.sort()
                DF.init_circle_segment(MID, MID, INIT_RAD, angles)
                init_front = current_front
                draw()
            }

            function draw() {
                if(CO < 5) {
                    current_front = FRONT
                } else if(CO < 9 && CO > 4) {
                    current_front = currendColorStore[colorIndex]
                    if(colorIndex >= currendColorStore.length - 1) {
                    co = 2
                    } 
                    if(colorIndex <= 0) {
                    co = 1
                    }

                    if(co == 1) {
                    colorIndex ++
                    } else {
                    colorIndex --
                    }
                } else {
                    current_front = fullColorStack[colorIndex]
                    if(colorIndex >= fullColorStack.length - 1) {
                    co = 2
                    } 
                    if(colorIndex <= 0) {
                    co = 1
                    }

                    if(co == 1) {
                    colorIndex ++
                    } else {
                    colorIndex --
                    }
                }
                wrap(render)
                requestAnimationFrame(draw)
            }

            function wrap (render) {
                np_coords       = []
                for(let i = 0; i < NMAX; i ++) {
                    np_coords[i] = [0,0,0,0]
                }
                let res     = steps(DF)
                let num     = DF.np_get_edges_coordinates(np_coords)
                let real  = np_coords.slice(0, num)

                if(pulse_start) {
                    real = pulse_path.shift() 
                    if(pulse_path.length >= pulse_num * step_count) {
                        pulse_erase = true
                        pulse_fill = false
                    } else {
                        pulse_erase = false
                        pulse_fill = true
                    }
                } else {
                    if(growth_flag) {
                        draw_path.push(real)
                    } else {
                        real = draw_path.pop()
                    }
                    if(real == undefined) {
                        setup()
                        return
                    }
                }
                clear_canvas()
                
                for(let i = 0; i < real.length; i ++) {
                    let point = real[i]
                    let x1 = point[0]
                    let y1 = point[1]
                    let x2 = point[2]
                    let y2 = point[3]

                    let r =  ONE / 3
                    circles(x1, y1, x2, y2, r)
                }
                return res
            }
            function steps(df) {
                if(pulse_start) {
                    if(pulse_path.length == 0) {
                    pulse_start = false
                    if(step_count < RYTHM - 1) {
                        step_count ++
                    } else {
                        step_count = 1
                    }
                    step_length = step_unit * step_count
                    }
                } else {
                    if(growth_flag) {
                    df.optimize_position(STP)
                    spawn(df, NEARL, 0.5)
                    }
                    if(check_step(step_length, df)) {
                        if(step_count < RYTHM - 1) {
                            pulse_start = true
                            let drawLength = draw_path.length
                            for(let i = 1; i <= pulse_num * step_count; i ++ ) {
                            pulse_path.push(draw_path[drawLength - i])
                            }
                            for(let i = pulse_num * step_count; i > 0; i -- ) {
                            pulse_path.push(draw_path[drawLength - i])
                            }
                        } else {
                            if(RYTHM == 1) {
                                cancelAnimationFrame(draw)
                            }                                                                                                                                                           

                            if(growth_flag) {
                                cancelAnimationFrame(draw)
                                sleep(parseInt(RYTHM + 1) * 1000)
                                requestAnimationFrame(draw)
                            }
                            growth_flag = false
                        }
                    }
                }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
            }

            function check_step(step, df) {
                CURRENTSIZE = step
                let result = df.safe_vertex_positions(3 * STP) < 0
                CURRENTSIZE = RS
                return result
            }

            function sleep(milliseconds) {
                const date = Date.now();
                let currentDate = null;
                do {
                    currentDate = Date.now();
                } while (currentDate - date < milliseconds);
            }
            preload()
            setup()
        </script>
    </canvas>
</body>
</html>