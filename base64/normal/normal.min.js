function long_array_init(t,e,s){for(let r=0;r<e;r++)t[r]=s;return t}function add_e_to_ve(t,e,s){s[2*t]<0?s[2*t]=e:s[2*t+1]=e}function del_e_from_ve(t,e,s){return s[2*t]==e?(s[2*t]=s[2*t+1],s[2*t+1]=-1):s[2*t+1]==e&&(s[2*t+1]=-1),s}function spawn(t,e,s){const r=t.get_enum();let n=[],o=[];for(let t=0;t<r;t++)n.push(Math.random());const h=n.length;for(i=0;i<h;i++)n[i]>s||!n[i]||o.push(i);let _=o.length;for(let s=0;s<_;s++){if(!(t.get_edge_length(o[s])<e))try{t.split_edge(o[s])}catch(t){continue}}}Math.seedrandom=function(t){var e=4294967295,s=123456789+t&e,r=987654321-t&e;return function(){var t=((r=36969*(65535&r)+(r>>>16)&e)<<16)+(65535&(s=18e3*(65535&s)+(s>>>16)&e))>>>0;return t/=4294967296}};class Segments{constructor(t,e){this.X=[],long_array_init(this.X,t,0),this.Y=[],long_array_init(this.Y,t,0),this.VA=[],long_array_init(this.VA,t,0),this.VS=[],long_array_init(this.VS,t,-1),this.EV=[],long_array_init(this.EV,2*t,-1),this.VE=[],long_array_init(this.VE,2*t,-1),this.nmax=t,this.vnum=0,this.edgeNumber=0,this.snum=0,this.zonewidth=e,this.nz=1/e,this.nz<3&&(this.nz=1,this.zonewidth=1),this.zonemap=new Zonemap(this.nz),this.zonemap.__assign_xy_arrays(this.X,this.Y)}__valid_new_vertex(t,e){return t<0||t>1||e<0||e>1?-1:1}__add_vertex(t,e,s){if(this.__valid_new_vertex(t,e)<0)throw new Error("Vertext outside unit square.");const r=this.vnum;return this.X[r]=t,this.Y[r]=e,this.VA[r]=1,this.VS[r]=s,this.zonemap.add_vertex(r),this.vnum=r+1,r}__add_edge(t,e){t=parseInt(t),e=parseInt(e);const s=this.edgeNumber;return this.EV[2*s]=t,this.EV[2*s+1]=e,add_e_to_ve(t,s,this.VE),add_e_to_ve(e,s,this.VE),this.edgeNumber+=1,s}__edge_exists(t){return this.EV[2*t]>-1&&this.EV[2*t+1]>-1?1:-1}__del_vertex(t){return this.VA[t]=-1,this.zonemap.del_vertex(t),1}__del_edge(t){if(t<0||t>this.edgeNumber-1)throw new Error("invalid edge in __del_edge e1"+t);let e=this.EV[2*t],s=this.EV[2*t+1];return this.EV[2*t]=-1,this.EV[2*t+1]=-1,e>-1&&del_e_from_ve(e,t,this.VE),s>-1&&del_e_from_ve(s,t,this.VE),1}np_get_edges_coordinates(t){let e=this.edgeNumber,s=0;for(let r=0;r<e;r++)if(this.EV[2*r]>-1){let e=this.EV[2*r],i=this.EV[2*r+1];t[s][0]=this.X[e],t[s][1]=this.Y[e],t[s][2]=this.X[i],t[s][3]=this.Y[i],s+=1}return s}get_edge_length(t){let e=this.X[this.EV[2*t]]-this.X[this.EV[2*t+1]],s=this.Y[this.EV[2*t]]-this.Y[this.EV[2*t+1]];return Math.sqrt(e*e+s*s)}init_circle_segment(t,e,s,r){let i=[],n=this.snum,o=r.length;for(let h=0;h<o;h++){const o=r[h],_=t+Math.cos(o)*s,l=e+Math.sin(o)*s;i.push(this.__add_vertex(_,l,n))}for(let t=0;t<i.length-1;t++)this.__add_edge(i[t],i[t+1]);this.__add_edge(i[0],i[o-1]),this.snum=n+1}split_edge(t,e=-1){if(this.__edge_exists(t)<0)throw new Error("e1 does not exist");if(t<0)throw new Error("invalid edge in split_edge e1"+t);let s=this.EV[2*t],r=this.EV[2*t+1],i=this.VS[s];if(i<0)throw new Error("Invalid segment id.");if(e>0){let i=this.X[s]-this.X[r],n=this.Y[s]-this.Y[r];if(i*i+n*n<e*e)throw new Error("edge too short, e1,"+t)}let n=.5*(this.X[s]+this.X[r]),o=.5*(this.Y[s]+this.Y[r]),h=this.__add_vertex(n,o,i);return this.__del_edge(t),this.__add_edge(s,h),this.__add_edge(r,h),1}safe_vertex_positions(t){let e=this.vnum;for(let s=0;s<e;s++){if(this.X[s]<(RS-CURRENTSIZE)/2/RS+t||this.X[s]>1-(RS-CURRENTSIZE)/2/RS-t)return-1;if(this.Y[s]<(RS-CURRENTSIZE)/2/RS+t||this.Y[s]>1-(RS-CURRENTSIZE)/2/RS-t)return-1}return 1}get_enum(){return this.edgeNumber}}class DifferentialLine extends Segments{constructor(t,e,s,r){super(t,e),this.SX=new Array,this.SY=new Array,this.SD=new Array,this.nearl=s,this.farl=r}optimize_position(t){let e=new Array;const s=this.vnum;for(let r=0;r<s;r++){this.SX[r]=0,this.SY[r]=0;let s=this.zonemap.__sphere_vertices(this.X[r],this.Y[r],this.farl,e);this.__reject(r,e,s,t,this.SX,this.SY)}for(let t=0;t<s;t++)this.VA[t]<0||(this.X[t]=this.X[t]+this.SX[t],this.Y[t]=this.Y[t]+this.SY[t]);for(let t=0;t<s;t++)if(!(this.VA[t]<0))try{this.zonemap.__update_v(t)}catch{}}__reject(t,e,s,r,i,n){if(this.VA[t]<1)return-1;let o,h,_=this.VE[2*t],l=this.VE[2*t+1];o=this.EV[2*_]==t?this.EV[2*_+1]:this.EV[2*_],h=this.EV[2*l]==t?this.EV[2*l+1]:this.EV[2*l];let a=0,u=0;for(let i=0;i<s;i++){let s=e[i],n=this.X[t]-this.X[s],_=this.Y[t]-this.Y[s],l=Math.sqrt(n*n+_*_);if(s==o||s==h){if(l<this.nearl||l<=0)continue;a+=-n/l*r,u+=-_/l*r}else{if(l>this.farl||l<=0)continue;a+=n*(this.farl/l-1)*r,u+=_*(this.farl/l-1)*r}}return i[t]+=a,n[t]+=u,1}}function clear_canvas(){ctx.fillStyle="rgb("+BACK.toString()+")",ctx.fillRect(0,0,SIZE,SIZE)}function circles(t,e,s,r,i,n=2,o=!1){let h=t-s,_=e-r,l=Math.sqrt(h**2+_**2),a=parseInt(l/ONE);a<n&&(a=n);let u=Math.atan2(_,h),c=linspace(0,l,a);for(let s=0;s<c.length;s++){let r=t-c[s]*Math.cos(u),n=e-c[s]*Math.sin(u);ctx.beginPath(),ctx.strokeStyle=o&&(!growth_flag||pulse_erase)?"rgb("+BACK.toString()+")":CO<5?"rgb("+init_front.toString()+")":"rgb("+current_front.toString()+")",ctx.arc(r*RS,n*RS,i*RS,0,TWOPI),ctx.stroke()}}function linspace(t,e,s,r=!0){const i=(e-t)/(r?s-1:s);return Array.from({length:s},(e,s)=>t+i*s)}class Zonemap{constructor(t){t=parseInt(t);this.VZ=[],this.Z=[],this.vnum=0,this.vsize=RS,this.nz=t,this.total_zones=t*t,this.greatest_zone_size=RS;for(let t=0;t<this.total_zones;t++){let e=[];e.i=t,e.size=RS,e.count=0,e.ZV=[],this.Z[t]=e}}__assign_xy_arrays(t,e){this.X=t,this.Y=e}__add_v_to_zone(t,e){t=parseInt(t),e=parseInt(e);let s=this.Z[t];return null==s&&((s=[]).count=0,s.ZV=[],s.i=0,s.size=SIZE,this.Z.push(s)),s.ZV[s.count]=e,s.count+=1,s.count>=s.size-1?this.__extend_zv_of_zone(s):1}__extend_zv_of_zone(t){let e=2*t.size;return t.ZV=[],t.size=e,e>this.greatest_zone_size&&(this.greatest_zone_size=e),this.Z.push(t),1}__remove_v_from_zone(t,e){t=parseInt(t),e=parseInt(e);let s=this.Z[t];for(let t=0;t<s.count;t++)if(s.ZV[t]==e)return s.ZV[t]=s.ZV[s.count-1],s.count-=1,1;return-1}__get_z(t,e){const s=this.nz;return s*parseInt(t*s)+parseInt(e*s)}__sphere_vertices(t,e,s,r){const i=this.nz,n=parseInt(t*i),o=parseInt(e*i);let h=0;const _=s*s;for(let s=Math.max(n-1,0);s<Math.min(n+2,i);s++)for(let n=Math.max(o-1,0);n<Math.min(o+2,i);n++){const o=this.Z[s*i+n];for(let s=0;s<o.count;s++){const i=t-this.X[o.ZV[s]],n=e-this.Y[o.ZV[s]];i*i+n*n<_&&(r[h]=o.ZV[s],h+=1)}}return h}add_vertex(t){t=parseInt(t);let e=this.vnum;const s=this.X[t],r=this.Y[t],i=this.__get_z(s,r);this.__add_v_to_zone(i,e),this.VZ[e]=i;const n=[];return this.vnum>=this.vsize-1&&(this.VZ=n,this.vsize=2*this.vsize),this.vnum+=1,e}del_vertex(t){return this.__remove_v_from_zone(this.VZ[t],t),this.VZ[t]=-1,1}update_v(t){t=parseInt(t);const e=this.X[t],s=this.Y[t],r=parseInt(this.__get_z(e,s)),i=parseInt(this.VZ[t]);return i<0?-1:r!=i?(this.__remove_v_from_zone(i,t),this.__add_v_to_zone(r,t),this.VZ[t]=r,1):-1}}const SIZE=400,CO=5,RYTHM=3,INDEX=1,RS=SIZE,NMAX=1e5,ONE=1/RS,STP=ONE,NEARL=3*ONE,FARL=30*ONE,INIT_RAD=6*ONE,INIT_NUM=4,MID=.5,TWOPI=2*Math.PI;let FRONT,BACK,CURRENTSIZE,np_coords,np_vert_coords,growth_flag,DF,render,coloroptions,current_front,step_length,ctx,init_front,step_count=1,draw_path=[],pulse_path=[],pulse_num=parseInt(SIZE/30),pulse_start=!1,pulse_erase=!1,pulse_fill=!1,currendColorStore=[],colorIndex=0,co=1,fullColorStack=[];function preload(){FRONT=[[255,0,0],[0,255,0]],BACK=[0,0,0],make_color_store()}function make_color_store(){let t=FRONT[0],e=FRONT[1];if(t[0]>e[0])for(let s=t[0];s>=e[0];s--)currendColorStore.push([s,t[1],t[2]]);else for(let s=t[0];s<=e[0];s++)currendColorStore.push([s,t[1],t[2]]);if(t[1]>e[1])for(let s=t[1];s>=e[1];s--)currendColorStore.push([e[0],s,t[2]]);else for(let s=t[1];s<=e[1];s++)currendColorStore.push([e[0],s,t[2]]);if(t[2]>e[2])for(let s=t[2];s>=e[2];s--)currendColorStore.push([e[0],e[1],s]);else for(let s=t[2];s<=e[2];s++)currendColorStore.push([e[0],e[1],s])}function setup(){let t=document.getElementById("canvas");t.width=SIZE,t.height=SIZE,ctx=t.getContext("2d"),step_count=1,RYTHM>2?(CURRENTSIZE=RS,step_unit=parseInt(RS/(RYTHM-1)),step_length=parseInt(RS/(RYTHM-1))):step_length=step_unit=CURRENTSIZE=RS,growth_flag=!0,colorIndex=0,Math.seedrandom(INDEX),current_front=CO>4&&CO<9?FRONT[0]:FRONT,DF=new DifferentialLine(NMAX,2*FARL,NEARL,FARL);let e=[];for(let t=0;t<INIT_NUM;t++)e.push(Math.random()*TWOPI);e.sort(),DF.init_circle_segment(MID,MID,INIT_RAD,e),init_front=current_front,draw()}function draw(){current_front=currendColorStore[colorIndex],colorIndex>=currendColorStore.length-1&&(co=2),colorIndex<=0&&(co=1),1==co?colorIndex++:colorIndex--,wrap(render),requestAnimationFrame(draw)}function wrap(t){np_coords=[];for(let t=0;t<NMAX;t++)np_coords[t]=[0,0,0,0];let e=steps(DF),s=DF.np_get_edges_coordinates(np_coords),r=np_coords.slice(0,s);if(pulse_start)r=pulse_path.shift(),pulse_path.length>=pulse_num*step_count?(pulse_erase=!0,pulse_fill=!1):(pulse_erase=!1,pulse_fill=!0);else if(growth_flag?draw_path.push(r):r=draw_path.pop(),null==r)return void setup();clear_canvas();for(let t=0;t<r.length;t++){let e=r[t];circles(e[0],e[1],e[2],e[3],ONE/3)}return e}function steps(t){if(pulse_start)0==pulse_path.length&&(pulse_start=!1,step_count<RYTHM-1?step_count++:step_count=1,step_length=step_unit*step_count);else if(growth_flag&&(t.optimize_position(STP),spawn(t,NEARL,.5)),check_step(step_length,t))if(step_count<RYTHM-1){pulse_start=!0;let t=draw_path.length;for(let e=1;e<=pulse_num*step_count;e++)pulse_path.push(draw_path[t-e]);for(let e=pulse_num*step_count;e>0;e--)pulse_path.push(draw_path[t-e])}else 1==RYTHM&&cancelAnimationFrame(draw),growth_flag&&(cancelAnimationFrame(draw),sleep(1e3*parseInt(RYTHM+1)),requestAnimationFrame(draw)),growth_flag=!1}function check_step(t,e){CURRENTSIZE=t;let s=e.safe_vertex_positions(3*STP)<0;return CURRENTSIZE=RS,s}function sleep(t){const e=Date.now();let s=null;do{s=Date.now()}while(s-e<t)}preload(),setup();