<!DOCTYPE html>
<html lang="">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coral Unique 1</title>
    <style>
        body {
        padding: 0;
        margin: 0;
        }
    </style>
    </head>
    <body>
        <canvas id="canvas">
            <script>
                Math.seedrandom=function(s){
                    var mask=0xffffffff,m_w=(123456789+s)&mask,m_z=(987654321-s)&mask;
                    return function(){m_z=(36969*(m_z&65535)+(m_z>>>16))&mask;m_w=(18000*(m_w&65535)+(m_w>>>16))&mask;
                        var result=((m_z<<16)+(m_w&65535))>>>0;result/=4294967296;return result;
                    }
                };
                class Zonemap {
                    constructor(nz) {
                        nz = parseInt(nz)
                        const total_zones = nz ** 2
                        this.VZ                     = []
                        this.Z                      = []

                        this.vnum                   = 0
                        this.vsize                  = RS

                        this.nz                     = nz
                        this.total_zones            = nz*nz
                        this.greatest_zone_size     = RS

                        for (let i = 0; i < this.total_zones ; i ++) {

                            let z = []

                            z.i = i
                            z.size = RS
                            z.count = 0
                            z.ZV = []

                            this.Z[i] = z
                        }
                    }
                    _ac(X,Y) {
                        this.X = X
                        this.Y = Y
                        return
                    }
                    _ad(v1) {
                        v1 = parseInt(v1)
                        let vnum = this.vnum

                        const x = this.X[v1]
                        const y = this.Y[v1]

                        const z1 = this._ai(x,y)

                        this._af(z1, vnum)
                        this.VZ[vnum] = z1

                        const new_vz = []
                        
                        if (this.vnum>=this.vsize-1) {
                            this.VZ = new_vz;
                            this.vsize = this.vsize*2
                        }

                        this.vnum += 1
                        return vnum
                    }
                    _ae(v1) {

                        v1 = parseInt(v1)
                        this._ah(this.VZ[v1], v1)
                        this.VZ[v1] = -1

                        return 1
                    }
                    _af(z1, v1) {
                    
                        z1 = parseInt(z1)
                        v1 = parseInt(v1)

                        let z = this.Z[z1]
                        if(z == undefined) {
                            z = []
                            z.count = 0
                            z.ZV = []
                            z.i = 0
                            z.size = SIZE

                            this.Z.push(z)
                        }
                        z.ZV[z.count] = v1
                        z.count += 1

                        if (z.count>=z.size-1) {
                            return this._ag(z)
                        }

                        return 1
                    }
                    _ag(z) {

                        let new_size = z.size*2
                        const new_zv = []
                        z.ZV = new_zv;
                        z.size = new_size
                        if (new_size>this.greatest_zone_size) {
                        this.greatest_zone_size = new_size
                        }

                        this.Z.push(z)
                        return 1
                    }
                    _ah(z1, v1) {
                        z1 = parseInt(z1)
                        v1 = parseInt(v1)

                        let z = this.Z[z1]
                        for (let i = 0; i < z.count ;  i ++) {

                            if (z.ZV[i] == v1) {
                            z.ZV[i] = z.ZV[z.count-1]
                            z.count -= 1
                            return 1
                            }
                        }

                        return -1
                    }
                    _ai(x, y) {

                        const nz = this.nz

                        const i = parseInt(x*nz)
                        const j = parseInt(y*nz)
                        const z = nz*i + j

                        return z
                    }
                    _aj(v1) {
                        v1 = parseInt(v1)
                        const x = this.X[v1]
                        const y = this.Y[v1]
                        const new_z = parseInt(this._ai(x, y))
                        const old_z = parseInt(this.VZ[v1])

                        if (old_z<0) {
                            return -1
                        }

                        if (new_z != old_z) {
                            this._ah(old_z, v1)
                            this._af(new_z, v1)
                            this.VZ[v1] = new_z

                            return 1
                        }

                        return -1
                    }
                    _ak(x, y, rad, vertices) {

                        const nz = this.nz

                        const zx = parseInt(x*nz)
                        const zy = parseInt(y*nz)

                        let num = 0

                        const rad2 = rad*rad


                        for (let a = Math.max(zx-1,0); a < Math.min(zx+2,nz); a ++) {
                            for (let b = Math.max(zy-1,0); b < Math.min(zy+2,nz); b ++ ) {
                            
                            const z = this.Z[a*nz+b]

                            for (let i = 0; i < z.count; i ++) {

                                const dx = x-this.X[z.ZV[i]]
                                const dy = y-this.Y[z.ZV[i]]

                                if (dx*dx+dy*dy<rad2) {

                                vertices[num] = z.ZV[i]
                                num += 1
                                }
                            }
                            }
                        }
                        return num
                    }
                }
                class Segments {
                    constructor(nmax, zonewidth) {
                        this.X = []
                        _e(this.X, nmax, 0)
                        this.Y = []
                        _e(this.Y, nmax, 0)
                        this.VA =  []
                        _e(this.VA, nmax, 0)
                        this.VS = []
                        _e(this.VS, nmax, -1)
                        this.EV = []
                        _e(this.EV, 2*nmax, -1)
                        this.VE = []
                        _e(this.VE, 2* nmax, -1)

                        this.nmax = nmax

                        this.vnum = 0

                        this.edgeNumber = 0

                        this.snum = 0

                        this.zonewidth = zonewidth

                        this.nz = 1.0 /zonewidth

                        if (this.nz<3) {
                            this.nz = 1
                            this.zonewidth = 1.0
                        }

                        this.zonemap = new Zonemap(this.nz)
                        this.zonemap._ac(this.X, this.Y)
                    }
                    _m(x,  y) {
                        if (x<0 || x>1 || y<0 || y>1) 
                            return -1
                        return 1
                    }
                    _n(x, y, s, p) {
                        if (this._m(x,y)<0) {
                            throw new Error("Vertext outside unit square.")
                        }

                        const vnum = this.vnum
                        
                        this.X[vnum] = x
                        this.Y[vnum] = y
                        this.VA[vnum] = 1
                        this.VS[vnum] = s

                        this.zonemap._ad(vnum)

                        this.vnum = vnum + 1
                        return vnum
                    }

                    _o(v1,  v2) {
                        if (v1<0 || v1>this.vnum-1 || this.VA[v1]<0) {
                            return -1
                        }

                        if (v2<0 || v2>this.vnum-1 || this.VA[v2]<0) {
                            return -1
                        }

                        return 1
                    }

                    _p(v1,  v2) {
                        v1 = parseInt(v1)
                        v2 = parseInt(v2)
                        const edgeNumber = this.edgeNumber
                        if (this._o(v1,v2)<0) {
                            throw new Error("invalid vertex in _p v1, v2, " + v1 + ',' + v2)
                        }

                        this.EV[2*edgeNumber] = v1
                        this.EV[2*edgeNumber+1] = v2

                        _f(v1, edgeNumber, this.VE)
                        _f(v2, edgeNumber, this.VE)

                        this.edgeNumber += 1
                        return edgeNumber
                    }

                    _q(e1) {

                        if (this.EV[2*e1]>-1 && this.EV[2*e1+1]>-1) {
                            return 1
                        }
                        else {
                            return -1
                        }
                    }

                    _r(v1) {

                        this.VA[v1] = -1

                        this.zonemap._ae(v1)

                        return 1
                    }

                    _s(e1) {

                        if (e1<0 || e1>this.edgeNumber-1) {
                            throw new Error("invalid edge in _s e1" + e1)
                        }

                        let v1 = this.EV[2*e1]
                        let v2 = this.EV[2*e1+1]

                        this.EV[2*e1] = -1
                        this.EV[2*e1+1] = -1

                        if (v1>-1) {
                        _g(v1, e1, this.VE)
                        }
                        if (v2>-1) {
                        _g(v2, e1, this.VE)
                        }

                        return 1
                    }

                    _t(a) {

                        let edgeNumber = this.edgeNumber
                        let n = 0

                        for (let e = 0; e < edgeNumber; e ++ ) {

                            if (this.EV[2*e]>-1) {

                                let v1 = this.EV[2*e]
                                let v2 = this.EV[2*e+1]
                                a[n][0] = this.X[v1]
                                a[n][1] = this.Y[v1]
                                a[n][2] = this.X[v2]
                                a[n][3] = this.Y[v2]

                                n+=1
                            }
                        }

                        return n
                    }

                    _u(a) {

                        let vnum = this.vnum
                        let n = 0

                        for (let v = 0; v < vnum; v ++) {

                            if (this.VA[v]>-1) {

                                a[n][0] = this.X[v]
                                a[n][1] = this.Y[v]
                                n+=1
                            }
                        }

                        return n
                    }

                    _v(e1) {

                        let nx = this.X[this.EV[2*e1]] - this.X[this.EV[2*e1+1]]
                        let ny = this.Y[this.EV[2*e1]] - this.Y[this.EV[2*e1+1]]
                        let length = Math.sqrt(nx*nx+ny*ny)

                        return length
                    }

                    _w(xys, lock_edges=1) {

                        let vertices = []
                        let snum = this.snum
                        let xx, yy

                        if (lock_edges>0) {

                            xx = xys[0][0]
                            yy =  xys[0][1]

                            vertices.push(this._n(xx,yy,snum,0))

                            for(let i = 1; i < xys.length - 1 ; i ++) {
                            xx = xys[i][0]
                            yy = xys[i][1]
                            vertices.push(this._n(xx, yy, snum, 1))
                            }

                            xx = xys[xys.length - 1][0]
                            yy = xys[xys.length - 1][1]
                            vertices.push(this._n(xx,yy,snum,0))
                        }

                        else {
                            for (let i = 0 ; i < xys.length; i ++ ) {
                            xx = xys[i][0]
                            yy = xys[i][1]
                            vertices.push(this._n(xx,yy,snum,1))
                            }
                        }

                        for (let i = 0; i < vertices.length - 1; i ++) {
                            this._p(vertices[i],vertices[i+1])
                        }

                        this.snum = snum+1
                    }

                    _x(x, y, r, angles) {
                        
                        let vertices = []
                        let snum = this.snum

                        let num_angles = angles.length

                        for (let i = 0; i < num_angles; i ++) {
                            const the = angles[i]

                            const xx = x + Math.cos(the)*r
                            const yy = y + Math.sin(the)*r

                            vertices.push(this._n(xx,yy,snum,1))
                        }

                        for (let i = 0; i < vertices.length-1; i ++) {
                            this._p(vertices[i],vertices[i+1])
                        }

                        this._p(vertices[0],vertices[num_angles-1])
                        this.snum = snum+1
                    }

                    _y(e1, minimum_length=-1) {
                        if (this._q(e1)<0) {
                            throw new Error("e1 does not exist")
                        }
                        if (e1<0) {
                            throw new Error("invalid edge in _y e1" + e1)
                        }

                        let v1 = this.EV[2*e1]
                        let v2 = this.EV[2*e1+1]

                        let s = this.VS[v1]

                        if (s<0) {
                            throw new Error("Invalid segment id.")
                        }

                        if (minimum_length>0) {
                            let dx = this.X[v1] - this.X[v2]
                            let dy = this.Y[v1] - this.Y[v2]

                            if (dx*dx+dy*dy<minimum_length*minimum_length) {
                            throw new Error("edge too short, e1," + e1)
                            }
                        }

                        let midx = (this.X[v1] + this.X[v2])*0.5
                        let midy = (this.Y[v1] + this.Y[v2])*0.5

                        let v3 = this._n(midx,midy,s,1)
                        this._s(e1)

                        this._p(v1,v3)
                        this._p(v2,v3)

                        return 1
                    }
                    _aa(limit) {
                        let vnum = this.vnum
                        for (let i = 0 ; i < vnum ; i ++) {
                            if( this.X[i] < ((RS - CS) / 2 / RS + limit) || this.X[i] > (1 - (RS - CS) / 2 / RS - limit) ) {
                                return - 1
                            }
                            if(this.Y[i] < ((RS - CS) / 2 / RS + limit) || this.Y[i] > (1 - (RS - CS) / 2 / RS - limit)) {
                                return -1
                            }
                        }
                        return 1
                    }

                    _ab() {
                        return this.edgeNumber
                    }
                }
                class DifferentialLine extends Segments {

                    constructor(nmax, zonewidth, nearl, farl) {
                        super(nmax, zonewidth)

                        this.SX = []
                        this.SY = []
                        this.SD = []

                        this.nearl = nearl
                        this.farl = farl
                    }

                    _a(step) {
                        let vertices = []
                        const vnumCount = this.vnum
                        for(let v = 0; v < vnumCount; v ++ ) {
                            this.SX[v] = 0.0
                            this.SY[v] = 0.0

                            let num = this.zonemap._ak(
                                this.X[v],
                                this.Y[v],
                                this.farl,
                                vertices
                            )
                            this._b(
                                v, 
                                vertices,
                                num, 
                                step,
                                this.SX,
                                this.SY
                            )

                        }
                        for (let v = 0; v < vnumCount ; v ++) {
                            if(this.VA[v] < 0) {
                                continue
                            }

                            this.X[v] = this.X[v] + this.SX[v]
                            this.Y[v] = this.Y[v] + this.SY[v]
                        }

                        for(let v = 0; v < vnumCount; v ++) {
                            if(this.VA[v] < 0) {
                                continue
                            }
                            try {
                                this.zonemap._aj(v)
                            }
                            catch {
                            }
                        }
                    }

                    _b(v, vertices, num, step, sx, sy) {
                        if(this.VA[v] < 1) {
                            return -1
                        }

                        let e1 = this.VE[2*v]
                        let e2 = this.VE[2*v + 1]
                        let v1, v2
                        // connected vertices to v, v1 and v2
                        if(this.EV[2*e1] == v) {
                            v1 = this.EV[2*e1 + 1]
                        } else {
                            v1 = this.EV[2*e1]
                        }

                        if(this.EV[2*e2] == v) {
                            v2 = this.EV[2*e2 + 1]
                        } else {
                            v2 =  this.EV[2*e2]
                        }

                        let resx = 0
                        let resy = 0

                        for(let k = 0; k < num; k ++) {
                            let neigh =  vertices[k]
                            let dx = this.X[v] - this.X[neigh]
                            let dy =  this.Y[v] -  this.Y[neigh]

                            let nrm = Math.sqrt(dx * dx + dy * dy)

                            if(neigh == v1 || neigh == v2) {
                                if(nrm < this.nearl || nrm <= 0) {
                                    continue
                                }

                                resx += -dx/nrm *step
                                resy += -dy/nrm * step
                            } else {
                                if(nrm > this.farl || nrm <= 0) {
                                    continue
                                }
                                resx += dx * (this.farl/nrm -1) *step
                                resy += dy * (this.farl/nrm-1)*step
                            }
                        }
                        sx[v] += resx
                        sy[v] += resy

                        return 1

                    }
                }
                function _c (df, d, limit) {
                    const edgeNumber  = df._ab()
                    let rnd = []
                    let rndmask = []
                    for(let i = 0; i < edgeNumber ; i ++) {
                        rnd.push(Math.random())
                    }

                    const rndLength = rnd.length
                    for(i = 0; i < rndLength ; i ++) {
                        if(rnd[i] > limit || !rnd[i]) {
                            continue
                        }

                        rndmask.push(i)
                    }
                    let rndmaskLength = rndmask.length
                    
                    for(let i = 0 ; i < rndmaskLength; i ++) {
                        let l = df._v(rndmask[i])

                        if(l < d) {
                            continue
                        }

                        try {
                            df._y(rndmask[i])
                        } 
                        catch(e) {
                            continue
                        }
                    }
                }

                function _e(a, n, v) {
                    for(let i = 0; i < n; i ++) {
                        a[i] = v
                    }

                    return a
                }

                function _f(v, e, ve) {
                    if(ve[2*v] < 0) {
                        ve[2*v] = e
                    } else {
                        ve[2*v + 1] = e
                    }
                }

                function _g(v, e, ve) {
                    if(ve[2*v] == e ) {
                        ve[2*v] = ve[2*v + 1]
                        ve[2*v + 1] = -1
                    } else if(ve[2*v + 1] == e) {
                        ve[2*v + 1] = -1
                    }

                    return ve
                }
                function _h() {
                    ctx.fillStyle = BACK
                    ctx.fillRect(0,0,RS,RS)
                }

                function _k(xys) {
                    let xyLength = xys.length
                    for(let i = 0; i < xyLength; i ++) {
                        let point = xys[i]
                        let x = point[0]
                        let y =  point[1]
                        if(!gf || pe) {
                            ctx.strokeStyle = 'rgb(' + BACK.toString() + ')'
                        } else {
                            if(CO < 5) {
                                ctx.strokeStyle = 'rgb(' + FRONT.toString() + ')'
                            } else {
                                ctx.strokeStyle = 'rgb(' + cf.toString() + ')'
                            }
                        }
                        ctx.strokeRect(x * RS,y * RS, ONE * RS, ONE * RS)
                    }
                }

                function _l(xys) {
                    const xyLength = xys.length
                    
                    for(let i = 0; i < xyLength ; i ++ ) {
                        let point = xys[i]
                        let dx = point[2] - point[0]
                        let dy = point[3] - point[1]
                        let aa = Math.atan2(dy, dx)
                        let direct =  [Math.cos(aa), Math.sin(aa)]
                        let dd = Math.sqrt(dx ** 2, dy ** 2)
                        let random = Math.random() * dd
                        let x = point[0] + direct[0] * random
                        let y = point[1] + direct[1] * random
                        
                        if(!gf || pe) {
                            ctx.fillStyle = 'rgb(' + BACK.toString() + ')'
                        } else {
                            if(CO < 5) {
                                ctx.fillStyle = 'rgb(' + FRONT.toString() + ')'
                            } else {
                                ctx.fillStyle = 'rgb(' + cf.toString() + ')'
                            }
                        }
                        ctx.fillRect(x * RS, y * RS, ONE * RS, ONE * RS);
                    }
                }
                // Those variables contain the trait of the coral.

                const SIZE          = 1200       // Growth size
                const CO   = 9         // Coloroption
                const RYTHM         = 9         // Growth RYTHM

                // Those are the config value that the algorithm uses. Do not modify this value or the coral will be changed unexpectedly.

                const INDEX         = 1
                const RS      = SIZE
                const NMAX          = 10 ** 4
                const ONE           = 1 / RS
                const STP           = 1  * ONE
                const NEARL         = 10 * ONE
                const FARL          = 100 * ONE
                const INIT_RAD      = 5     * ONE
                const INIT_NUM      = 12
                const MID           = 0.5
                const TWOPI         = 2 * Math.PI
                let FRONT, BACK, CS

                let nc, nvc, gf, DF, coloroptions, cf
                let sc = 1, sl, dp = [], pp = [], pn = 100, ps = false, pe = false, pf = false
                let ccs = [], ci = 0, co = 1, fcs = []
                let ctx

                function preload() {
                    FRONT = [255, 0,0]
                    BACK = [0,0,0]

                    _mfcs()
                    _mcs()
                }

                function _mfcs() {
                    for(let i = 0; i <256; i ++) {
                        fcs.push([255, 0, i])
                    }
                    for(let i = 255; i >= 0; i --) {
                        fcs.push([i, 0, 255])
                    }
                    for(let i = 0; i <256; i ++) {
                        fcs.push([0, i, 255])
                    }
                    for(let i = 255; i >= 0; i --) {
                        fcs.push([0, 255, i])
                    }
                    for(let i = 0; i <256; i ++) {
                        fcs.push([i, 255, 0])
                    }
                    for(let i = 255; i >=0; i --) {
                        fcs.push([255, i, 0])
                    }
                }

                function _mcs() {
                    let stackLength = fcs.length
                    for(let i = 0; i < stackLength; i ++) {
                        if(fcs[i].join(',') === FRONT.join(',')) {
                            ci = i
                            break
                        }
                    }
                }

                function _ics() {
                    sc = 1
                    if(RYTHM > 2) {
                        CS = RS
                        step_unit   = parseInt(RS / (RYTHM - 1))
                        sl = parseInt(RS / (RYTHM - 1))
                    } else {
                        sl = step_unit = CS = RS
                    }
                }

                function setup() {
                    let canvas = document.getElementById('canvas')
                    canvas.width = SIZE
                    canvas.height = SIZE
                    ctx = canvas.getContext('2d')
                    _ics()
                    gf = true
                    if(CO < 9)
                        ci  = 0

                    Math.seedrandom(INDEX)
                    if(CO > 4 && CO < 9) {
                        cf = FRONT[0]
                    } else {
                        cf = FRONT
                    }
                    DF = new DifferentialLine(NMAX, FARL * 2, NEARL, FARL)

                    let angles = []
                    for(let i = 0; i < INIT_NUM ; i ++ ) {
                        angles.push(Math.random() * TWOPI)
                    }
                    angles.sort()
                    DF._x(MID, MID, FARL * 0.1, angles)
                    _h()
                    draw()
                }

                function draw() {
                    cf = fcs[ci]
                    if(ci >= fcs.length - 1) {
                    co = 2
                    } 
                    if(ci <= 0) {
                    co = 1
                    }

                    if(co == 1) {
                    ci ++
                    } else {
                    ci --
                    }
                    wrap()
                    requestAnimationFrame(draw)
                }

                function wrap () {
                    _ic()
                    let res     = steps(DF)
                    let num     = DF._t(nc)
                    let real  = nc.slice(0, num)
                    if(ps) {
                        real = pp.shift() 
                        if(pp.length >= pn * sc) {
                            pe = true
                            pf = false
                        } else {
                            pe = false
                            pf = true
                        }
                    } else {
                        if(gf) {
                            dp.push(real)
                        } else {
                            real = dp.pop()
                        }
                        if(real == undefined) {
                            setup()
                            return
                        }
                    }
                    
                    _l(real)
                    if(Math.random() < 0.1) {
                        let vert_num = DF._u(nvc)
                        real = nvc.slice(0, vert_num)

                        _k(real)
                    }
                    return res
                }

                function _ic() {
                    nc       = []
                    nvc  = []
                    for(let i = 0; i < NMAX; i ++) {
                        nc[i] = [0,0,0,0]
                    }
                    for(let i = 0; i < NMAX; i ++) {
                        nvc[i] = [0,0,0,0]
                    }
                }

                function steps(df) {
                    if(ps) {
                        if(pp.length == 0) {
                        ps = false
                        if(sc < RYTHM - 1) {
                            sc ++
                        } else {
                            sc = 1
                        }
                        sl = step_unit * sc
                        }
                    } else {
                        if(gf) {
                            df._a(STP)
                            _c(df, NEARL, 0.8 * NEARL)
                        }
                        if(check_step(sl, df)) {
                            if(sc < RYTHM - 1) {
                                ps = true
                                let drawLength = dp.length
                                for(let i = 1; i <= pn * sc; i ++ ) {
                                pp.push(dp[drawLength - i])
                                }
                                for(let i = pn * sc; i > 0; i -- ) {
                                pp.push(dp[drawLength - i])
                                }
                            } else {
                                if(RYTHM == 1) {
                                    cancelAnimationFrame(draw)
                                }

                                if(gf) {
                                    cancelAnimationFrame(draw)
                                    sleep(parseInt(RYTHM + 1) * 1000)
                                    requestAnimationFrame(draw)
                                }
                                gf = false
                            }
                        }
                    }
                }

                function check_step(step, df) {
                    CS = step
                    let result = df._aa(3 * STP) < 0
                    CS = RS
                    return result
                }

                function sleep(milliseconds) {
                    const date = Date.now();
                    let currentDate = null;
                    do {
                        currentDate = Date.now();
                    } while (currentDate - date < milliseconds);
                }
                preload()
                setup()
            </script>
        </canvas>
    </body>
</html>