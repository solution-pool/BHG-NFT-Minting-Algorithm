<canvas id="canvas"></canvas> 
<script>
  // Those variables contain the trait of the coral.

let SIZE          = 400       // Growth s
let SPEED         = 1         // Growth speed
let LOCATION      = 1         // Location
let CO   = 7         // Coloroption
let RYTHM         = 4         // Growth RYTHM

// Those are the config value that the algorithm uses. Do not modify this value or the coral will be changed unexpectedly.

let INDEX         = 1
let RS      = SIZE
let NMAX          = 10 ** 6
let ONE           = 1 / RS
let STP           = 0.1 * ONE
let NEARL         = 10 * ONE
let FARL          = 100 * ONE
let INIT_RAD      = 6 * ONE
let INIT_NUM      = 3
let MID           = 0.5
let TWOPI         = 2 * Math.PI
let FRONT = [[255,0,0], [0,255,0], [0,0,255]]
let BACK = [0,0,0]

let p1=(a)=>{
  return parseInt(a)
}
let e1=()=>{
  throw new Error(1)
}
class Zm {

    constructor(n) {
      n = p1(n)
      let t = n ** 2
      this.VZ                     = []
      this.Z                      = []
  
      this.v                   = 0
      this.s                  = RS
  
      this.n                     = n
      this.t            = n*n
      this.g     = RS
  
      for (let i = 0; i < this.t ; i ++) {
  
        let z = []
  
        z.i = i
        z.s = RS
        z.co = 0
        z.ZV = []
  
        this.Z[i] = z
      }
    }
    a2(X,Y) {
  
      this.X = X
      this.Y = Y
  
      return
    }
    a3(v1) {
      v1 = p1(v1)
      let v = this.v
  
      let x = this.X[v1]
      let y = this.Y[v1]
  
      let z1 = this.a8(x,y)
  
      this.a5(z1, v)
      this.VZ[v] = z1
      if (this.v>=this.s-1) {
        this.VZ = [];
        this.s = this.s*2
      }
  
      this.v += 1
      return v
    }
    a4(v1) {
  
      v1 = p1(v1)
      this.a7(this.VZ[v1], v1)
      this.VZ[v1] = -1
  
      return 1
    }
    a5(z1, v1) {
      
      z1 = p1(z1)
      v1 = p1(v1)
  
      let z = this.Z[z1]
      if(z == undefined) {
        z = []
        z.co = 0
        z.ZV = []
        z.i = 0
        z.s = SIZE
  
        this.Z.push(z)
      }
      z.ZV[z.co] = v1
      z.co += 1
  
      if (z.co>=z.s-1)
        return this.a6(z)
  
      return 1
    }
    a6(z) {
  
      let new_s = z.s*2
        z.ZV = [];
        z.s = new_s
        if (new_s>this.g)
          this.g = new_s
  
        this.Z.push(z)
      return 1
    }
    a7(z1, v1) {
      z1 = p1(z1)
      v1 = p1(v1)
  
      let z = this.Z[z1]
      for (let i = 0; i < z.co ;  i ++) {
  
        if (z.ZV[i] == v1) {
          z.ZV[i] = z.ZV[z.co-1]
          z.co -= 1
          return 1
        }
      }
  
      return -1
    }
    a8(x, y) {
      let n = this.n
      return n*p1(x*n) + p1(y*n)
    }
    a9(v1) {
      v1 = p1(v1)
      let x = this.X[v1]
      let y = this.Y[v1]
      let new_z = p1(this.a8(x, y))
      let old_z = p1(this.VZ[v1])
  
      if (old_z<0)
        return -1
  
      if (new_z != old_z) {
        this.a7(old_z, v1)
        this.a5(new_z, v1)
        this.VZ[v1] = new_z
  
        return 1
      }
      return -1
    }
    a0(x, y, rad, ve) {
  
      let n = this.n
  
      let zx = p1(x*n)
      let zy = p1(y*n)
  
      let num = 0
  
      let rad2 = rad*rad
  
  
      for (let a = Math.max(zx-1,0); a < Math.min(zx+2,n); a ++) {
        for (let b = Math.max(zy-1,0); b < Math.min(zy+2,n); b ++ ) {
          
          let z = this.Z[a*n+b]
  
          for (let i = 0; i < z.co; i ++) {
  
            let dx = x-this.X[z.ZV[i]]
            let dy = y-this.Y[z.ZV[i]]
  
            if (dx*dx+dy*dy<rad2) {
  
              ve[num] = z.ZV[i]
              num += 1
            }
          }
        }
      }
      return num
    }
  }
  class Se {

constructor(nmax, zw) {
    this.X = []
    _e(this.X, nmax, 0)
    this.Y = []
    _e(this.Y, nmax, 0)
    this.VA =  []
    _e(this.VA, nmax, 0)
    this.VS = []
    _e(this.VS, nmax, -1)
    this.EV = []
    _e(this.EV, 2*nmax, -1)
    this.VE = []
    _e(this.VE, 2* nmax, -1)

    this.nmax = nmax

    this.v = 0

    this.eN = 0

    this.sn = 0

    this.zw = zw

    this.n = 1.0 /zw

    if (this.n<3) {
        this.n = 1
        this.zw = 1.0
    }

    this.zm = new Zm(this.n)
    this.zm.a2(this.X, this.Y)
}
_m(x,  y) {
    if (x<0 || x>1 || y<0 || y>1) 
        return -1
    return 1
}
_n(x, y, s, p) {
    if (this._m(x,y)<0)
        el()

    let v = this.v
    
    this.X[v] = x
    this.Y[v] = y
    this.VA[v] = 1
    this.VS[v] = s

    this.zm.a3(v)

    this.v = v + 1
    return v
}

_o(v1,  v2) {
    if (v1<0 || v1>this.v-1 || this.VA[v1]<0 || v2<0 || v2>this.v-1 || this.VA[v2]<0)
      return -1
    return 1
}

_p(v1,  v2) {
    v1 = p1(v1)
    v2 = p1(v2)
    let eN = this.eN
    if (this._o(v1,v2)<0)
        el()

    this.EV[2*eN] = v1
    this.EV[2*eN+1] = v2

    _f(v1, eN, this.VE)
    _f(v2, eN, this.VE)

    this.eN += 1
}

_q(e1) {

    if (this.EV[2*e1]>-1 && this.EV[2*e1+1]>-1)
        return 1
      return -1
}
_s(e1) {

    if (e1<0 || e1>this.eN-1)
        el()

    let v1 = this.EV[2*e1]
    let v2 = this.EV[2*e1+1]

    this.EV[2*e1] = -1
    this.EV[2*e1+1] = -1

    if (v1>-1)
      _g(v1, e1, this.VE)
    if (v2>-1)
      _g(v2, e1, this.VE)
  }

_t(a) {

    let eN = this.eN
    let n = 0

    for (let e = 0; e < eN; e ++ )

        if (this.EV[2*e]>-1) {

            let v1 = this.EV[2*e]
            let v2 = this.EV[2*e+1]
            a[n][0] = this.X[v1]
            a[n][1] = this.Y[v1]
            a[n][2] = this.X[v2]
            a[n][3] = this.Y[v2]

            n+=1
        }

    return n
}

_u(a) {

    let v = this.v
    let n = 0

    for (let v = 0; v < v; v ++)

        if (this.VA[v]>-1) {

            a[n][0] = this.X[v]
            a[n][1] = this.Y[v]
            n+=1
        }

    return n
}

_v(e1) {

  let nx = this.X[this.EV[2*e1]] - this.X[this.EV[2*e1+1]]
  let ny = this.Y[this.EV[2*e1]] - this.Y[this.EV[2*e1+1]]
  return Math.sqrt(nx*nx+ny*ny)
}

_x(x, y, r, angles) {
  
  let ve = []
  let sn = this.sn

  let num_angles = angles.length

  for (let i = 0; i < num_angles; i ++) {
    let the = angles[i]

    let xx = x + Math.cos(the)*r
    let yy = y + Math.sin(the)*r

    ve.push(this._n(xx,yy,sn,1))
  }

  for (let i = 0; i < ve.length-1; i ++)
    this._p(ve[i],ve[i+1])

  this._p(ve[0],ve[num_angles-1])
  this.sn = sn+1
}

_y(e1, ml=-1) {
  if (this._q(e1)<0) 
    el()
  if (e1<0) 
    el()

  let v1 = this.EV[2*e1]
  let v2 = this.EV[2*e1+1]

  let s = this.VS[v1]

  if (s<0)
    el()

  if (ml>0) {
    let dx = this.X[v1] - this.X[v2]
    let dy = this.Y[v1] - this.Y[v2]

    if (dx*dx+dy*dy<ml*ml)
      el()
  }

  let midx = (this.X[v1] + this.X[v2])*0.5
  let midy = (this.Y[v1] + this.Y[v2])*0.5

  let v3 = this._n(midx,midy,s,1)
  this._s(e1)

  this._p(v1,v3)
  this._p(v2,v3)
}

_z(e1) {

  if (this._q(e1)<0)
    el()

  if (e1<0)
    el()

  let va = this.EV[2*e1]
  let vb = this.EV[2*e1+1]
  let e2, e3

  if (va<0 || vb<0)
    el()
  if (this.VE[2*va] == this.VE[2*vb]) {
    e2 = this.VE[2*va+1]
    e3 = this.VE[2*vb+1]
  }
  else if (this.VE[2*va] == this.VE[2*vb+1]) {
    e2 = this.VE[2*va+1]
    e3 = this.VE[2*vb]
  }
  else if (this.VE[2*va+1] == this.VE[2*vb]) {
    e2 = this.VE[2*va]
    e3 = this.VE[2*vb+1]
  }
  else if (this.VE[2*va+1] == this.VE[2*vb+1]) {
    e2 = this.VE[2*va]
    e3 = this.VE[2*vb]
  }
  else
    el()

  let v3 = this.EV[2*e1]
  let v4 = this.EV[2*e1+1]
  let v1, v2, ax, bx, ay, by
  let t = 0.0
  
  if (e2>-1) {
    v1 = this.EV[2*e2]
    v2 = this.EV[2*e2+1]

    ax = this.X[v1] - this.X[v2]
    bx = this.X[v3] - this.X[v4]
    ay = this.Y[v1] - this.Y[v2]
    by = this.Y[v3] - this.Y[v4]

    t += Math.abs(ax*by - ay*bx)*0.5
  }
  if (e3>-1) {
    v1 = this.EV[2*e3]
    v2 = this.EV[2*e3+1]

    ax = this.X[v1] - this.X[v2]
    bx = this.X[v3] - this.X[v4]
    ay = this.Y[v1] - this.Y[v2]
    by = this.Y[v3] - this.Y[v4]

    t += Math.abs(ax*by - ay*bx)*0.5
  }
  
  if (t<=0)
    el()

  return t
}

a1(limit) {
  let v = this.v
  for (let i = 0 ; i < v ; i ++) {
      if( this.X[i] < ((RS - CS) / 2 / RS + limit) || this.X[i] > (1 - (RS - CS) / 2 / RS - limit) ) {
        return - 1
      }
      if(this.Y[i] < ((RS - CS) / 2 / RS + limit) || this.Y[i] > (1 - (RS - CS) / 2 / RS - limit)) {
          return -1
      }
  }
  return 1
}

_ab() {
    return this.eN
}
}
class Di extends Se {

constructor(nmax, zw, nearl, farl) {
    super(nmax, zw)

    this.SX = []
    this.SY = []
    this.SD = []

    this.nearl = nearl
    this.farl = farl
}

_a(step) {
    let ve = []
    let vCount = this.v
    for(let v = 0; v < vCount; v ++ ) {
        this.SX[v] = 0
        this.SY[v] = 0

        let num = this.zm.a0(
            this.X[v],
            this.Y[v],
            this.farl,
            ve
        )
        this._b(
            v, 
            ve,
            num, 
            step,
            this.SX,
            this.SY
        )

    }
    for (let v = 0; v < vCount ; v ++) {
        if(this.VA[v] < 0)
            continue

        this.X[v] = this.X[v] + this.SX[v]
        this.Y[v] = this.Y[v] + this.SY[v]
    }

    for(let v = 0; v < vCount; v ++) {
        if(this.VA[v] < 0)
            continue
        try {
            this.zm.a9(v)
        }
        catch {
        }
    }
}

_b(v, ve, num, step, sx, sy) {
    if(this.VA[v] < 1)
        return -1

    let e1 = this.VE[2*v]
    let e2 = this.VE[2*v + 1]
    let v1, v2
    // connected ve to v, v1 and v2
    if(this.EV[2*e1] == v)
        v1 = this.EV[2*e1 + 1]
    else
        v1 = this.EV[2*e1]

    if(this.EV[2*e2] == v)
        v2 = this.EV[2*e2 + 1]
    else 
        v2 =  this.EV[2*e2]

    let resx = 0
    let resy = 0

    for(let k = 0; k < num; k ++) {
        let neigh =  ve[k]
        let dx = this.X[v] - this.X[neigh]
        let dy =  this.Y[v] -  this.Y[neigh]

        let nrm = Math.sqrt(dx * dx + dy * dy)

        if(neigh == v1 || neigh == v2) {
            if(nrm < this.nearl || nrm <= 0)
                continue

            resx += -dx/nrm *step
            resy += -dy/nrm * step
        } else {
            if(nrm > this.farl || nrm <= 0)
                continue
            resx += dx * (this.farl/nrm -1) *step
            resy += dy * (this.farl/nrm-1)*step
        }
    }
    sx[v] += resx
    sy[v] += resy

    return 1

}
}

function _d(df, limit, prob_spawn=1.0) {
    let eN = df._ab()
    let ind_curv = []
    let tot_curv = []
    let max_curv = -100000

    for(let e = 0; e < eN; e ++) {
        try {
            let t = df._z(e)
            ind_curv[e] = t
            tot_curv += t
            max_curv = Math.max(max_curv, t)
        } catch (e) {
        }
    }
    for(let i = 0; i < ind_curv.length; i ++) {
        if(Math.random() <ind_curv[i] / max_curv * prob_spawn) {
            try {
                df._y(i, limit)
            } catch (e) {
            }
        }
    }
}
function _e(a, n, v) {
    for(let i = 0; i < n; i ++)
        a[i] = v

    return a
}

function _f(v, e, ve) {
    if(ve[2*v] < 0) 
        ve[2*v] = e
   else 
        ve[2*v + 1] = e
}

function _g(v, e, ve) {
    if(ve[2*v] == e ) {
        ve[2*v] = ve[2*v + 1]
        ve[2*v + 1] = -1
    } else if(ve[2*v + 1] == e) {
        ve[2*v + 1] = -1
    }

    return ve
}
!function(a, b, c, d, e, f, g, h, i) {
    function j(a) {
        var b, c = a.length, e = this, f = 0, g = e.i = e.j = 0, h = e.S = [];
        for (c || (a = [c++]); d > f; )
            h[f] = f++;
        for (f = 0; d > f; f++)
            h[f] = h[g = s & g + a[f % c] + (b = h[f])],
            h[g] = b;
        (e.g = function(a) {
            for (var b, c = 0, f = e.i, g = e.j, h = e.S; a--; )
                b = h[f = s & f + 1],
                c = c * d + h[s & (h[f] = h[g = s & g + b]) + (h[g] = b)];
            return e.i = f,
            e.j = g,
            c
        }
        )(d)
    }
    function k(a, b) {
        var c, d = [], e = typeof a;
        if (b && "object" == e)
            for (c in a)
                try {
                    d.push(k(a[c], b - 1))
                } catch (f) {}
        return d.length ? d : "string" == e ? a : a + "\0"
    }
    function l(a, b) {
        for (var c, d = a + "", e = 0; e < d.length; )
            b[s & e] = s & (c ^= 19 * b[s & e]) + d.charCodeAt(e++);
        return n(b)
    }
    function m(c) {
        try {
            return o ? n(o.randomBytes(d)) : (a.crypto.getRandomValues(c = new Uint8Array(d)),
            n(c))
        } catch (e) {
            return [+new Date, a, (c = a.navigator) && c.plugins, a.screen, n(b)]
        }
    }
    function n(a) {
        return String.fromCharCode.apply(0, a)
    }
    var o, p = c.pow(d, e), q = c.pow(2, f), r = 2 * q, s = d - 1, t = c["seed" + i] = function(a, f, g) {
        var h = [];
        f = 1 == f ? {
            entropy: !0
        } : f || {};
        var o = l(k(f.entropy ? [a, n(b)] : null == a ? m() : a, 3), h)
          , s = new j(h);
        return l(n(s.S), b),
        (f.pass || g || function(a, b, d) {
            return d ? (c[i] = a,
            b) : a
        }
        )(function() {
            for (var a = s.g(e), b = p, c = 0; q > a; )
                a = (a + c) * d,
                b *= d,
                c = s.g(1);
            for (; a >= r; )
                a /= 2,
                b /= 2,
                c >>>= 1;
            return (a + c) / b
        }, o, "global"in f ? f.global : this == c)
    }
    ;
    if (l(c[i](), b),
    g && g.exports) {
        g.exports = t;
        try {
            o = require("crypto")
        } catch (u) {}
    } else
        h && h.amd && h(function() {
            return t
        })
}(this, [], Math, 256, 6, 52, "object" == typeof module && module, "function" == typeof define && define, "random");

function _h() {
    ctx.fillStyle = 'rgb(' + BACK.toString() + ')'
    ctx.fillRect(0,0,RS,RS)
}

function _k(xys) {
    let xyLength = xys.length
    for(let i = 0; i < xyLength; i ++) {
        let point = xys[i]
        let x = point[0]
        let y =  point[1]
        if(!gf || pe) {
            ctx.strokeStyle = 'rgb(' + BACK.toString() + ')'
        } else {
                ctx.strokeStyle = 'rgb(' + cf.toString() + ')'
        }
        ctx.strokeRect(x * RS,y * RS, ONE * RS, ONE * RS)
    }
}

function _l(xys) {
    let xyLength = xys.length
    
    for(let i = 0; i < xyLength ; i ++ ) {
        let point = xys[i]
        let dx = point[2] - point[0]
        let dy = point[3] - point[1]
        let aa = Math.atan2(dy, dx)
        let direct =  [Math.cos(aa), Math.sin(aa)]
        let dd = Math.sqrt(dx ** 2, dy ** 2)
        let random = Math.random() * dd
        let x = point[0] + direct[0] * random
        let y = point[1] + direct[1] * random
        
        if(!gf || pe)
            ctx.strokeStyle = 'rgb(' + BACK.toString() + ')'
        else
                ctx.strokeStyle = 'rgb(' + cf.toString() + ')'

        ctx.strokeRect(x * RS, y * RS, ONE * RS, ONE * RS);
    }
}
let nc, nvc, gf, DF, cf
let sc = 1, sl, dp = [], pp = [], pn = p1(SIZE / (RYTHM + 1)), ps = false, pe = false, pf = false
let ccs = [], ci = 0, co = 1, fcs = []
let ctx, ai, CS

function m1() {
    let first = FRONT[0]
    let second = FRONT[1]
    let last  = FRONT[2]

    if(first[0] > second[0]) {
      for(let i = first[0]; i >= second[0]; i --) {
        ccs.push([i, first[1], first[2]])
      } 
    } else {
      for(let i = first[0]; i <= second[0]; i ++) {
        ccs.push([i, first[1], first[2]])
      }
    }

    if(first[1] > second[1]) {
      for(let i = first[1]; i >= second[1]; i --) {
        ccs.push([second[0], i, first[2]])
      } 
    } else {
      for(let i = first[1]; i <= second[1]; i ++) {
        ccs.push([second[0], i, first[2]])
      }
    }

    if(first[2] > second[2]) {
      for(let i = first[2]; i >= second[2]; i --) {
        ccs.push([second[0], second[1], i])
      } 
    } else {
      for(let i = first[2]; i <= second[2]; i ++) {
        ccs.push([second[0], second[1], i])
      }
    }
    
    if(second[0] > last[0]) {
      for(let i = second[0]; i >= last[0]; i --) {
        ccs.push([i, second[1], second[2]])
      } 
    } else {
      for(let i = second[0]; i <= last[0]; i ++) {
        ccs.push([i, second[1], second[2]])
      }
    }

    if(second[1] > last[1]) {
      for(let i = second[1]; i >= last[1]; i --) {
        ccs.push([last[0], i, second[2]])
      } 
    } else {
      for(let i = second[1]; i <= last[1]; i ++) {
        ccs.push([last[0], i, second[2]])
      }
    }

    if(second[2] > last[2]) {
      for(let i = second[2]; i >= last[2]; i --) {
        ccs.push([last[0], last[1], i])
      } 
    } else {
      for(let i = second[2]; i <= last[2]; i ++) {
        ccs.push([last[0], last[1], i])
      }
    }
}
function _se() {
  m1()
  let canvas = document.getElementById('canvas')
  canvas.width = SIZE
  canvas.height = SIZE
  ctx = canvas.getContext('2d')
  sc = 1
  if(RYTHM > 2) {
    CS = RS
    step_unit   = p1(RS / (RYTHM - 1))
    sl = p1(RS / (RYTHM - 1))
  } else {
    sl = step_unit = CS = RS
  }
  gf = true
    ci  = 0

  Math.seedrandom(INDEX)
    cf = FRONT[0]
  DF = new Di(NMAX, FARL * 2, NEARL, FARL)

  let angles = []
  for(let i = 0; i < INIT_NUM ; i ++ ) {
    angles.push(Math.random() * TWOPI)
  }
  angles.sort()
  DF._x(MID, MID, FARL * 0.2 * (SIZE / 400), angles)
  _h()
  d1()
}

function d1() {
    cf = ccs[ci]
    if(ci >= ccs.length - 1) {
      co = 2
    } 
    if(ci <= 0) {
      co = 1
    }

    if(co == 1) {
      ci ++
    } else {
      ci --
    }
  w1()
  ai = requestAnimationFrame(d1)
}

function w1 () {
  nc       = []
  nvc  = []
  for(let i = 0; i < NMAX; i ++) {
    nc[i] = [0,0,0,0]
    nvc[i] = [0,0,0,0]
  }
    let res     = s1(DF)
    let num     = DF._t(nc)
    let real  = nc.slice(0, num)
    if(ps) {
      real = pp.shift() 
      if(pp.length >= pn * sc) {
        pe = true
        pf = false
      } else {
        pe = false
        pf = true
      }
    } else {
      if(gf) {
        dp.push(real)
      } else {
        real = dp.pop()
      }
      if(real == undefined) {
        _se()
        return
      }
    }
    
    _l(real)
    if(Math.random() < 0.1) {
      let vert_num = DF._u(nvc)
      real = nvc.slice(0, vert_num)

      _k(real)
    }
    return res
}
function s1(df) {
  if(ps) {
    if(pp.length == 0) {
      ps = false
      if(sc < RYTHM - 1) {
        sc ++
      } else {
        sc = 1
      }
      sl = step_unit * sc
    }
  } else {
    if(gf) {
      df._a(STP)
      _d(df, NEARL)
    }
    if(c1(sl, df)) {
      if(sc < RYTHM - 1) {
        ps = true
        let d1Length = dp.length
        for(let i = 1; i <= pn * sc; i ++ ) {
          pp.push(dp[d1Length - i])
        }
        for(let i = pn * sc; i > 0; i -- ) {
          pp.push(dp[d1Length - i])
        }
      } else {
        if(RYTHM == 1) {
          cancelAnimationFrame(ai)
        }

        if(gf) {
          cancelAnimationFrame(ai)
          _sl(p1(RYTHM + 1) * 1000)
          ai = requestAnimationFrame(d1)
        }
        gf = false
      }
    }
  }
}

function c1(step, df) {
  CS = step
  let result = df.a1(3 * STP) < 0
  CS = RS
  return result
}

function _sl(milliseconds) {
  let date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date < milliseconds);
}
_se()
  </script>