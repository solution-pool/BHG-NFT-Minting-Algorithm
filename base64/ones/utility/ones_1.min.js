class Zonemap{constructor(t){t=parseInt(t);this.VZ=[],this.Z=[],this.vnum=0,this.vsize=RS,this.nz=t,this.total_zones=t*t,this.greatest_zone_size=RS;for(let t=0;t<this.total_zones;t++){let i=[];i.i=t,i.size=RS,i.count=0,i.ZV=[],this.Z[t]=i}}_ac(t,i){this.X=t,this.Y=i}_ad(t){t=parseInt(t);let i=this.vnum;const s=this.X[t],e=this.Y[t],n=this._ai(s,e);this._af(n,i),this.VZ[i]=n;const h=[];return this.vnum>=this.vsize-1&&(this.VZ=h,this.vsize=2*this.vsize),this.vnum+=1,i}_ae(t){return t=parseInt(t),this._ah(this.VZ[t],t),this.VZ[t]=-1,1}_af(t,i){t=parseInt(t),i=parseInt(i);let s=this.Z[t];return null==s&&((s=[]).count=0,s.ZV=[],s.i=0,s.size=SIZE,this.Z.push(s)),s.ZV[s.count]=i,s.count+=1,s.count>=s.size-1?this._ag(s):1}_ag(t){let i=2*t.size;return t.ZV=[],t.size=i,i>this.greatest_zone_size&&(this.greatest_zone_size=i),this.Z.push(t),1}_ah(t,i){t=parseInt(t),i=parseInt(i);let s=this.Z[t];for(let t=0;t<s.count;t++)if(s.ZV[t]==i)return s.ZV[t]=s.ZV[s.count-1],s.count-=1,1;return-1}_ai(t,i){const s=this.nz;return s*parseInt(t*s)+parseInt(i*s)}_aj(t){t=parseInt(t);const i=this.X[t],s=this.Y[t],e=parseInt(this._ai(i,s)),n=parseInt(this.VZ[t]);return n<0?-1:e!=n?(this._ah(n,t),this._af(e,t),this.VZ[t]=e,1):-1}_ak(t,i,s,e){const n=this.nz,h=parseInt(t*n),r=parseInt(i*n);let o=0;const a=s*s;for(let s=Math.max(h-1,0);s<Math.min(h+2,n);s++)for(let h=Math.max(r-1,0);h<Math.min(r+2,n);h++){const r=this.Z[s*n+h];for(let s=0;s<r.count;s++){const n=t-this.X[r.ZV[s]],h=i-this.Y[r.ZV[s]];n*n+h*h<a&&(e[o]=r.ZV[s],o+=1)}}return o}}class Segments{constructor(t,i){this.X=[],_e(this.X,t,0),this.Y=[],_e(this.Y,t,0),this.VA=[],_e(this.VA,t,0),this.VS=[],_e(this.VS,t,-1),this.EV=[],_e(this.EV,2*t,-1),this.VE=[],_e(this.VE,2*t,-1),this.nmax=t,this.vnum=0,this.edgeNumber=0,this.snum=0,this.zonewidth=i,this.nz=1/i,this.nz<3&&(this.nz=1,this.zonewidth=1),this.zonemap=new Zonemap(this.nz),this.zonemap._ac(this.X,this.Y)}_m(t,i){return t<0||t>1||i<0||i>1?-1:1}_n(t,i,s,e){if(this._m(t,i)<0)throw new Error("Vertext outside unit square.");const n=this.vnum;return this.X[n]=t,this.Y[n]=i,this.VA[n]=1,this.VS[n]=s,this.zonemap._ad(n),this.vnum=n+1,n}_o(t,i){return t<0||t>this.vnum-1||this.VA[t]<0?-1:i<0||i>this.vnum-1||this.VA[i]<0?-1:1}_p(t,i){t=parseInt(t),i=parseInt(i);const s=this.edgeNumber;if(this._o(t,i)<0)throw new Error("invalid vertex in _p v1, v2, "+t+","+i);return this.EV[2*s]=t,this.EV[2*s+1]=i,_f(t,s,this.VE),_f(i,s,this.VE),this.edgeNumber+=1,s}_q(t){return this.EV[2*t]>-1&&this.EV[2*t+1]>-1?1:-1}_r(t){return this.VA[t]=-1,this.zonemap._ae(t),1}_s(t){if(t<0||t>this.edgeNumber-1)throw new Error("invalid edge in _s e1"+t);let i=this.EV[2*t],s=this.EV[2*t+1];return this.EV[2*t]=-1,this.EV[2*t+1]=-1,i>-1&&_g(i,t,this.VE),s>-1&&_g(s,t,this.VE),1}_t(t){let i=this.edgeNumber,s=0;for(let e=0;e<i;e++)if(this.EV[2*e]>-1){let i=this.EV[2*e],n=this.EV[2*e+1];t[s][0]=this.X[i],t[s][1]=this.Y[i],t[s][2]=this.X[n],t[s][3]=this.Y[n],s+=1}return s}_u(t){let i=this.vnum,s=0;for(let e=0;e<i;e++)this.VA[e]>-1&&(t[s][0]=this.X[e],t[s][1]=this.Y[e],s+=1);return s}_v(t){let i=this.X[this.EV[2*t]]-this.X[this.EV[2*t+1]],s=this.Y[this.EV[2*t]]-this.Y[this.EV[2*t+1]];return Math.sqrt(i*i+s*s)}_x(t,i,s,e){let n=[],h=this.snum,r=e.length;for(let o=0;o<r;o++){const r=e[o],a=t+Math.cos(r)*s,c=i+Math.sin(r)*s;n.push(this._n(a,c,h,1))}for(let t=0;t<n.length-1;t++)this._p(n[t],n[t+1]);this._p(n[0],n[r-1]),this.snum=h+1}_y(t,i=-1){if(this._q(t)<0)throw new Error("e1 does not exist");if(t<0)throw new Error("invalid edge in _y e1"+t);let s=this.EV[2*t],e=this.EV[2*t+1],n=this.VS[s];if(n<0)throw new Error("Invalid segment id.");if(i>0){let n=this.X[s]-this.X[e],h=this.Y[s]-this.Y[e];if(n*n+h*h<i*i)throw new Error("edge too short, e1,"+t)}let h=.5*(this.X[s]+this.X[e]),r=.5*(this.Y[s]+this.Y[e]),o=this._n(h,r,n,1);return this._s(t),this._p(s,o),this._p(e,o),1}_z(t){if(this._q(t)<0)throw new Error("e1 does not exist");if(t<0)throw new Error("invalid edge in _y e1"+t);let i,s,e=this.EV[2*t],n=this.EV[2*t+1];if(e<0||n<0)throw new Error("non-vertex");if(this.VE[2*e]==this.VE[2*n])i=this.VE[2*e+1],s=this.VE[2*n+1];else if(this.VE[2*e]==this.VE[2*n+1])i=this.VE[2*e+1],s=this.VE[2*n];else if(this.VE[2*e+1]==this.VE[2*n])i=this.VE[2*e],s=this.VE[2*n+1];else{if(this.VE[2*e+1]!=this.VE[2*n+1])throw new Error("edges not connected");i=this.VE[2*e],s=this.VE[2*n]}let h,r,o,a,c,l,u=this.EV[2*t],f=this.EV[2*t+1],p=0;if(i>-1&&(h=this.EV[2*i],r=this.EV[2*i+1],o=this.X[h]-this.X[r],a=this.X[u]-this.X[f],c=this.Y[h]-this.Y[r],l=this.Y[u]-this.Y[f],p+=.5*Math.abs(o*l-c*a)),s>-1&&(h=this.EV[2*s],r=this.EV[2*s+1],o=this.X[h]-this.X[r],a=this.X[u]-this.X[f],c=this.Y[h]-this.Y[r],l=this.Y[u]-this.Y[f],p+=.5*Math.abs(o*l-c*a)),p<=0)throw new Error("no curvature.");return p}_aa(t){let i=this.vnum;for(let s=0;s<i;s++){if(this.X[s]<(RS-CS)/2/RS+t||this.X[s]>1-(RS-CS)/2/RS-t)return-1;if(this.Y[s]<(RS-CS)/2/RS+t||this.Y[s]>1-(RS-CS)/2/RS-t)return-1}return 1}_ab(){return this.edgeNumber}}class DifferentialLine extends Segments{constructor(t,i,s,e){super(t,i),this.SX=[],this.SY=[],this.SD=[],this.nearl=s,this.farl=e}_a(t){let i=[];const s=this.vnum;for(let e=0;e<s;e++){this.SX[e]=0,this.SY[e]=0;let s=this.zonemap._ak(this.X[e],this.Y[e],this.farl,i);this._b(e,i,s,t,this.SX,this.SY)}for(let t=0;t<s;t++)this.VA[t]<0||(this.X[t]=this.X[t]+this.SX[t],this.Y[t]=this.Y[t]+this.SY[t]);for(let t=0;t<s;t++)if(!(this.VA[t]<0))try{this.zonemap._aj(t)}catch{}}_b(t,i,s,e,n,h){if(this.VA[t]<1)return-1;let r,o,a=this.VE[2*t],c=this.VE[2*t+1];r=this.EV[2*a]==t?this.EV[2*a+1]:this.EV[2*a],o=this.EV[2*c]==t?this.EV[2*c+1]:this.EV[2*c];let l=0,u=0;for(let n=0;n<s;n++){let s=i[n],h=this.X[t]-this.X[s],a=this.Y[t]-this.Y[s],c=Math.sqrt(h*h+a*a);if(s==r||s==o){if(c<this.nearl||c<=0)continue;l+=-h/c*e,u+=-a/c*e}else{if(c>this.farl||c<=0)continue;l+=h*(this.farl/c-1)*e,u+=a*(this.farl/c-1)*e}}return n[t]+=l,h[t]+=u,1}}function _d(t,i,s=1){let e=t._ab(),n=[],h=[],r=-1e5;for(let i=0;i<e;i++)try{let s=t._z(i);n[i]=s,h+=s,r=Math.max(r,s)}catch(t){}let o=n.length;for(let e=0;e<o;e++){let h=e;if(Math.random()<n[h]/r*s)try{t._y(h,minimum_length=i)}catch(t){}}}function _e(t,i,s){for(let e=0;e<i;e++)t[e]=s;return t}function _f(t,i,s){s[2*t]<0?s[2*t]=i:s[2*t+1]=i}function _g(t,i,s){return s[2*t]==i?(s[2*t]=s[2*t+1],s[2*t+1]=-1):s[2*t+1]==i&&(s[2*t+1]=-1),s}function _h(){ctx.fillStyle="rgb("+BACK.toString()+")",ctx.fillRect(0,0,RS,RS)}function _k(t){let i=t.length;for(let s=0;s<i;s++){let i=t[s],e=i[0],n=i[1];!gf||pe?ctx.strokeStyle="rgb("+BACK.toString()+")":CO<5?ctx.strokeStyle="rgb("+FRONT.toString()+")":ctx.strokeStyle="rgb("+cf.toString()+")",ctx.strokeRect(e*RS,n*RS,ONE*RS,ONE*RS)}}function _l(t){const i=t.length;for(let s=0;s<i;s++){let i=t[s],e=i[2]-i[0],n=i[3]-i[1],h=Math.atan2(n,e),r=[Math.cos(h),Math.sin(h)],o=Math.sqrt(e**2,n**2),a=Math.random()*o,c=i[0]+r[0]*a,l=i[1]+r[1]*a;!gf||pe?ctx.strokeStyle="rgb("+BACK.toString()+")":CO<5?ctx.strokeStyle="rgb("+FRONT.toString()+")":ctx.strokeStyle="rgb("+cf.toString()+")",ctx.strokeRect(c*RS,l*RS,ONE*RS,ONE*RS)}}let nc,nvc,gf,DF,render,coloroptions,cf;!function(t,i,s,e,n,h,r,o,a){function c(t){var i,s=t.length,n=this,h=0,r=n.i=n.j=0,o=n.S=[];for(s||(t=[s++]);e>h;)o[h]=h++;for(h=0;e>h;h++)o[h]=o[r=S&r+t[h%s]+(i=o[h])],o[r]=i;(n.g=function(t){for(var i,s=0,h=n.i,r=n.j,o=n.S;t--;)i=o[h=S&h+1],s=s*e+o[S&(o[h]=o[r=S&r+i])+(o[r]=i)];return n.i=h,n.j=r,s})(e)}function l(t,i){for(var s,e=t+"",n=0;n<e.length;)i[S&n]=S&(s^=19*i[S&n])+e.charCodeAt(n++);return f(i)}function u(s){try{return p?f(p.randomBytes(e)):(t.crypto.getRandomValues(s=new Uint8Array(e)),f(s))}catch(e){return[+new Date,t,(s=t.navigator)&&s.plugins,t.screen,f(i)]}}function f(t){return String.fromCharCode.apply(0,t)}var p,_=s.pow(e,6),V=s.pow(2,52),E=2*V,S=e-1,g=s["seed"+a]=function(t,n,h){var r=[],o=l(function t(i,s){var e,n=[],h=typeof i;if(s&&"object"==h)for(e in i)try{n.push(t(i[e],s-1))}catch(t){}return n.length?n:"string"==h?i:i+"\0"}((n=1==n?{entropy:!0}:n||{}).entropy?[t,f(i)]:null==t?u():t,3),r),p=new c(r);return l(f(p.S),i),(n.pass||h||function(t,i,e){return e?(s[a]=t,i):t})(function(){for(var t=p.g(6),i=_,s=0;V>t;)t=(t+s)*e,i*=e,s=p.g(1);for(;t>=E;)t/=2,i/=2,s>>>=1;return(t+s)/i},o,"global"in n?n.global:this==s)};if(l(s[a](),i),r&&r.exports){r.exports=g;try{p=require("crypto")}catch(t){}}else o&&o.amd&&o(function(){return g})}(this,[],Math,256,0,0,"object"==typeof module&&module,"function"==typeof define&&define,"random");let sl,ctx,ai,CS,sc=1,dp=[],pp=[],pn=parseInt(SIZE/(RYTHM+1)),ps=!1,pe=!1,pf=!1,ccs=[],ci=0,co=1,fcs=[];function init_current_size(){sc=1,RYTHM>2?(CS=RS,step_unit=parseInt(RS/(RYTHM-1)),sl=parseInt(RS/(RYTHM-1))):sl=step_unit=CS=RS}function setup(){let t=document.getElementById("canvas");t.width=SIZE,t.height=SIZE,ctx=t.getContext("2d"),init_current_size(),gf=!0,ci=0,Math.seedrandom(INDEX),cf=FRONT,DF=new DifferentialLine(NMAX,2*FARL,NEARL,FARL);let i=[];for(let t=0;t<INIT_NUM;t++)i.push(Math.random()*TWOPI);i.sort(),DF._x(MID,MID,.2*FARL*(SIZE/400),i),_h(),draw()}function draw(){cf=FRONT,wrap(),ai=requestAnimationFrame(draw)}function wrap(){init_coordinates();let t=steps(DF),i=DF._t(nc),s=nc.slice(0,i);if(ps)s=pp.shift(),pp.length>=pn*sc?(pe=!0,pf=!1):(pe=!1,pf=!0);else if(gf?dp.push(s):s=dp.pop(),null==s)return void setup();if(_l(s),Math.random()<.1){let t=DF._u(nvc);_k(s=nvc.slice(0,t))}return t}function init_coordinates(){nc=new Array,nvc=new Array;for(let t=0;t<NMAX;t++)nc[t]=[0,0,0,0];for(let t=0;t<NMAX;t++)nvc[t]=[0,0,0,0]}function steps(t){if(ps)0==pp.length&&(ps=!1,sc<RYTHM-1?sc++:sc=1,sl=step_unit*sc);else if(gf&&(t._a(STP),_d(t,NEARL)),check_step(sl,t))if(sc<RYTHM-1){ps=!0;let t=dp.length;for(let i=1;i<=pn*sc;i++)pp.push(dp[t-i]);for(let i=pn*sc;i>0;i--)pp.push(dp[t-i])}else 1==RYTHM&&cancelAnimationFrame(ai),gf&&(cancelAnimationFrame(ai),sleep(1e3*parseInt(RYTHM+1)),ai=requestAnimationFrame(draw)),gf=!1}function check_step(t,i){CS=t;let s=i._aa(3*STP)<0;return CS=RS,s}function sleep(t){const i=Date.now();let s=null;do{s=Date.now()}while(s-i<t)}setup();